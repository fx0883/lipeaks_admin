# 错误处理和最佳实践 - 详细文档

## 📋 目录

- [错误处理概述](#错误处理概述)
- [常见错误类型](#常见错误类型)
- [API最佳实践](#api最佳实践)
- [性能优化指南](#性能优化指南)
- [安全最佳实践](#安全最佳实践)
- [监控和调试](#监控和调试)
- [部署和运维](#部署和运维)

---

## ⚠️ 错误处理概述

### 错误响应标准格式

```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "用户友好的错误描述",
    "details": {
      "field_errors": {},
      "validation_errors": [],
      "additional_info": {}
    },
    "request_id": "550e8400-e29b-41d4-a716-446655440000",
    "timestamp": "2025-09-25T16:00:00Z",
    "documentation_url": "https://docs.example.com/errors/ERROR_CODE"
  }
}
```

### HTTP状态码规范

| 状态码 | 类型 | 说明 | 使用场景 |
|--------|------|------|----------|
| `200` | 成功 | 请求成功 | 正常操作完成 |
| `201` | 成功 | 创建成功 | 资源创建完成 |
| `400` | 客户端错误 | 请求参数错误 | 数据验证失败 |
| `401` | 客户端错误 | 未授权 | Token无效或过期 |
| `403` | 客户端错误 | 禁止访问 | 权限不足 |
| `404` | 客户端错误 | 资源不存在 | 找不到指定资源 |
| `409` | 客户端错误 | 冲突 | 资源冲突或业务规则冲突 |
| `422` | 客户端错误 | 数据验证失败 | 数据格式正确但业务验证失败 |
| `429` | 客户端错误 | 请求过多 | 触发限流 |
| `500` | 服务器错误 | 内部错误 | 系统异常 |
| `502` | 服务器错误 | 网关错误 | 上游服务不可用 |
| `503` | 服务器错误 | 服务不可用 | 系统维护或过载 |

---

## 🚨 常见错误类型

### 1. 认证和授权错误

#### 401 - Token无效或过期

```json
{
  "success": false,
  "error": {
    "code": "INVALID_TOKEN",
    "message": "认证令牌无效或已过期",
    "details": {
      "token_expired": true,
      "expiry_time": "2025-09-25T15:00:00Z",
      "refresh_token_available": true
    }
  }
}
```

**解决方案：**
```javascript
// 客户端自动刷新Token
const refreshToken = async () => {
  try {
    const response = await fetch('/api/auth/refresh/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        refresh_token: localStorage.getItem('refresh_token')
      })
    });
    
    if (response.ok) {
      const data = await response.json();
      localStorage.setItem('access_token', data.access_token);
      return data.access_token;
    }
  } catch (error) {
    // 重定向到登录页面
    window.location.href = '/login';
  }
};
```

#### 403 - 权限不足

```json
{
  "success": false,
  "error": {
    "code": "INSUFFICIENT_PERMISSIONS",
    "message": "权限不足，无法执行此操作",
    "details": {
      "required_permissions": ["can_manage_points"],
      "user_permissions": ["can_view_points"],
      "missing_permissions": ["can_manage_points"]
    }
  }
}
```

**解决方案：**
- 检查用户权限等级
- 联系管理员申请权限
- 使用有权限的账户操作

### 2. 业务逻辑错误

#### 积分余额不足

```json
{
  "success": false,
  "error": {
    "code": "INSUFFICIENT_POINTS",
    "message": "积分余额不足",
    "details": {
      "required_points": 1000,
      "available_points": 800,
      "shortage": 200,
      "suggestions": [
        "完成日常任务获得积分",
        "邀请朋友注册获得奖励",
        "购买积分包"
      ]
    }
  }
}
```

**解决方案：**
```python
def handle_insufficient_points(error_data):
    """处理积分不足错误"""
    details = error_data['error']['details']
    shortage = details['shortage']
    
    # 提供解决方案
    suggestions = [
        f"还需要 {shortage} 积分",
        "完成任务可快速获得积分",
        "邀请好友注册获得200积分奖励"
    ]
    
    return {
        'show_modal': True,
        'title': '积分不足',
        'message': f"当前积分: {details['available_points']}, 需要: {details['required_points']}",
        'suggestions': suggestions,
        'actions': [
            {'label': '去赚积分', 'action': 'navigate_to_tasks'},
            {'label': '邀请好友', 'action': 'open_referral'},
            {'label': '购买积分', 'action': 'open_store'}
        ]
    }
```

#### VIP权限冲突

```json
{
  "success": false,
  "error": {
    "code": "VIP_TAG_CONFLICT",
    "message": "VIP标签冲突，用户已拥有同类型VIP",
    "details": {
      "existing_tag": {
        "id": 5,
        "tag_name": "VIP银牌",
        "expires_at": "2025-12-31T23:59:59Z"
      },
      "requested_tag": {
        "id": 3,
        "tag_name": "VIP金牌"
      },
      "resolution_options": [
        "upgrade_existing",
        "extend_existing", 
        "replace_existing"
      ]
    }
  }
}
```

### 3. 数据验证错误

#### 422 - 数据验证失败

```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "请求数据验证失败",
    "details": {
      "field_errors": {
        "points_amount": [
          "积分数量必须大于0",
          "积分数量不能超过10000"
        ],
        "expires_at": [
          "过期时间不能早于当前时间"
        ],
        "category": [
          "无效的积分类别"
        ]
      },
      "valid_categories": ["login", "license", "referral", "manual"],
      "field_constraints": {
        "points_amount": {
          "min": 1,
          "max": 10000,
          "type": "integer"
        }
      }
    }
  }
}
```

**客户端验证示例：**
```javascript
class PointsValidator {
  static validateEarnPoints(data) {
    const errors = {};
    
    // 验证积分数量
    if (!data.points_amount || data.points_amount <= 0) {
      errors.points_amount = ['积分数量必须大于0'];
    } else if (data.points_amount > 10000) {
      errors.points_amount = ['单次积分数量不能超过10000'];
    }
    
    // 验证分类
    const validCategories = ['login', 'license', 'referral', 'manual'];
    if (!data.category || !validCategories.includes(data.category)) {
      errors.category = ['请选择有效的积分类别'];
    }
    
    // 验证过期时间
    if (data.expires_at && new Date(data.expires_at) < new Date()) {
      errors.expires_at = ['过期时间不能早于当前时间'];
    }
    
    return {
      isValid: Object.keys(errors).length === 0,
      errors: errors
    };
  }
}
```

### 4. 系统级错误

#### 500 - 服务器内部错误

```json
{
  "success": false,
  "error": {
    "code": "INTERNAL_SERVER_ERROR",
    "message": "服务器内部错误，请稍后重试",
    "details": {
      "error_id": "ERR_20250925_160001",
      "support_contact": "support@example.com",
      "retry_after": 30,
      "status_page": "https://status.example.com"
    }
  }
}
```

#### 503 - 服务不可用

```json
{
  "success": false,
  "error": {
    "code": "SERVICE_UNAVAILABLE",
    "message": "服务临时不可用，正在维护中",
    "details": {
      "maintenance_window": {
        "start": "2025-09-25T16:00:00Z",
        "end": "2025-09-25T18:00:00Z"
      },
      "estimated_downtime": "2 hours",
      "alternative_endpoints": []
    }
  }
}
```

---

## 🎯 API最佳实践

### 1. 请求设计最佳实践

#### 使用幂等性操作

```python
# 好的做法：幂等的积分操作
def earn_points_idempotent(user_id, operation_id, points_data):
    """幂等的积分操作"""
    
    # 检查操作是否已执行
    existing_operation = PointsOperation.objects.filter(
        user_id=user_id,
        operation_id=operation_id
    ).first()
    
    if existing_operation:
        return existing_operation.result
    
    # 执行操作
    with transaction.atomic():
        result = execute_points_operation(user_id, points_data)
        
        # 记录操作
        PointsOperation.objects.create(
            user_id=user_id,
            operation_id=operation_id,
            result=result
        )
        
        return result

# 客户端使用幂等性
const earnPoints = async (pointsData) => {
  const operationId = generateUUID();
  
  const response = await fetch('/api/v1/points/earn/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Idempotency-Key': operationId
    },
    body: JSON.stringify({
      operation_id: operationId,
      ...pointsData
    })
  });
  
  return response.json();
};
```

#### 批量操作优化

```javascript
// 好的做法：批量操作
const batchEarnPoints = async (userPointsData) => {
  const response = await fetch('/api/v1/points/batch-earn/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    },
    body: JSON.stringify({
      operations: userPointsData.map(data => ({
        user_id: data.userId,
        points_amount: data.points,
        category: data.category,
        reason: data.reason
      }))
    })
  });
  
  return response.json();
};

// 避免的做法：循环调用单个API
const inefficientEarnPoints = async (userPointsData) => {
  const results = [];
  
  // 这会产生过多的HTTP请求
  for (const data of userPointsData) {
    const result = await earnSinglePoints(data);
    results.push(result);
  }
  
  return results;
};
```

### 2. 错误处理最佳实践

#### 统一错误处理器

```javascript
class APIClient {
  constructor(baseURL, token) {
    this.baseURL = baseURL;
    this.token = token;
  }
  
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.token}`,
        ...options.headers
      },
      ...options
    };
    
    try {
      const response = await fetch(url, config);
      const data = await response.json();
      
      if (!response.ok) {
        throw new APIError(data.error, response.status);
      }
      
      return data;
    } catch (error) {
      if (error instanceof APIError) {
        throw error;
      }
      
      // 网络错误或其他异常
      throw new APIError({
        code: 'NETWORK_ERROR',
        message: '网络连接失败，请检查网络状态'
      }, 0);
    }
  }
}

class APIError extends Error {
  constructor(errorData, statusCode) {
    super(errorData.message);
    this.code = errorData.code;
    this.details = errorData.details;
    this.statusCode = statusCode;
  }
}

// 全局错误处理
const handleAPIError = (error) => {
  switch (error.code) {
    case 'INVALID_TOKEN':
      return refreshTokenAndRetry();
    
    case 'INSUFFICIENT_POINTS':
      return showPointsInsufficientModal(error.details);
    
    case 'VALIDATION_ERROR':
      return showValidationErrors(error.details.field_errors);
    
    case 'RATE_LIMIT_EXCEEDED':
      return showRateLimitMessage(error.details.retry_after);
    
    default:
      return showGenericError(error.message);
  }
};
```

#### 重试机制

```javascript
class RetryableRequest {
  constructor(maxRetries = 3, backoffMultiplier = 2) {
    this.maxRetries = maxRetries;
    this.backoffMultiplier = backoffMultiplier;
  }
  
  async executeWithRetry(requestFunc, retryableErrorCodes = ['NETWORK_ERROR', 'INTERNAL_SERVER_ERROR']) {
    let lastError;
    
    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
      try {
        return await requestFunc();
      } catch (error) {
        lastError = error;
        
        // 不可重试的错误直接抛出
        if (!retryableErrorCodes.includes(error.code)) {
          throw error;
        }
        
        // 最后一次尝试失败
        if (attempt === this.maxRetries) {
          throw error;
        }
        
        // 指数退避延迟
        const delay = Math.pow(this.backoffMultiplier, attempt) * 1000;
        await this.sleep(delay);
      }
    }
    
    throw lastError;
  }
  
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// 使用示例
const retryableRequest = new RetryableRequest(3, 2);

const earnPointsWithRetry = async (pointsData) => {
  return await retryableRequest.executeWithRetry(
    () => apiClient.request('/points/earn/', {
      method: 'POST',
      body: JSON.stringify(pointsData)
    })
  );
};
```

### 3. 缓存策略

#### 客户端缓存

```javascript
class CachedAPIClient {
  constructor(baseURL, token) {
    this.apiClient = new APIClient(baseURL, token);
    this.cache = new Map();
    this.cacheExpiry = new Map();
  }
  
  async getCached(key, fetchFunc, ttlSeconds = 300) {
    const now = Date.now();
    const expiry = this.cacheExpiry.get(key);
    
    // 缓存命中且未过期
    if (this.cache.has(key) && expiry && now < expiry) {
      return this.cache.get(key);
    }
    
    // 获取新数据
    const data = await fetchFunc();
    
    // 缓存数据
    this.cache.set(key, data);
    this.cacheExpiry.set(key, now + (ttlSeconds * 1000));
    
    return data;
  }
  
  // 用户等级数据缓存（变化频率低）
  async getUserLevels() {
    return this.getCached('user_levels', 
      () => this.apiClient.request('/points/user-levels/'),
      3600 // 1小时缓存
    );
  }
  
  // 用户积分数据缓存（变化频率中等）
  async getUserProfile(userId) {
    return this.getCached(`user_profile_${userId}`,
      () => this.apiClient.request(`/points/profiles/${userId}/`),
      300 // 5分钟缓存
    );
  }
  
  // 清除特定缓存
  invalidateCache(key) {
    this.cache.delete(key);
    this.cacheExpiry.delete(key);
  }
}
```

---

## ⚡ 性能优化指南

### 1. 数据库查询优化

#### 使用索引优化

```python
# Django模型索引优化
class TenantUserPoints(BaseModel):
    class Meta:
        indexes = [
            # 复合索引：租户 + 用户 + 创建时间
            models.Index(
                fields=['tenant', 'member', '-created_at'],
                name='idx_tenant_member_created'
            ),
            # 过期时间索引（部分索引）
            models.Index(
                fields=['expires_at'],
                name='idx_expires_at',
                condition=models.Q(expires_at__isnull=False, status='active')
            ),
            # 积分类型索引
            models.Index(
                fields=['tenant', 'point_type', 'category'],
                name='idx_tenant_type_category'
            )
        ]

# 查询优化示例
def get_user_points_optimized(tenant_id, user_id, limit=20):
    """优化的用户积分查询"""
    
    return TenantUserPoints.objects.filter(
        tenant_id=tenant_id,
        member_id=user_id
    ).select_related(
        'tenant_user_profile',
        'member'
    ).prefetch_related(
        'tenant_user_profile__current_level'
    ).order_by('-created_at')[:limit]
```

#### 查询集优化

```python
# 好的做法：使用select_related和prefetch_related
def get_user_profiles_optimized():
    return TenantUserProfile.objects.select_related(
        'member',
        'tenant', 
        'current_level'
    ).prefetch_related(
        'user_tags__tag',
        'points_records'
    ).filter(
        is_points_enabled=True
    )

# 避免的做法：N+1查询问题
def get_user_profiles_inefficient():
    profiles = TenantUserProfile.objects.all()
    
    for profile in profiles:
        # 每次循环都会产生数据库查询
        print(profile.member.username)  # N+1 query
        print(profile.current_level.level_name)  # N+1 query
        
        # 获取用户标签
        for tag in profile.user_tags.all():  # N+1 query
            print(tag.tag.tag_name)
```

### 2. API响应优化

#### 字段选择

```python
# Django REST Framework 字段选择
class TenantUserProfileViewSet(viewsets.ModelViewSet):
    
    def get_serializer_context(self):
        context = super().get_serializer_context()
        
        # 支持字段选择
        fields = self.request.query_params.get('fields')
        if fields:
            context['fields'] = fields.split(',')
        
        return context

class DynamicFieldsMixin:
    """动态字段序列化器混入类"""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        context = kwargs.get('context', {})
        fields = context.get('fields')
        
        if fields:
            # 只保留请求的字段
            allowed = set(fields)
            existing = set(self.fields)
            for field_name in existing - allowed:
                self.fields.pop(field_name)

# 使用示例
# GET /api/v1/points/profiles/?fields=id,total_points,current_level
```

#### 分页优化

```python
from rest_framework.pagination import CursorPagination

class OptimizedCursorPagination(CursorPagination):
    page_size = 20
    page_size_query_param = 'page_size'
    max_page_size = 100
    ordering = '-created_at'
    
    # 使用游标分页，适合大数据集
    def get_paginated_response(self, data):
        return Response({
            'next': self.get_next_link(),
            'previous': self.get_previous_link(),
            'results': data,
            'page_info': {
                'has_next': self.has_next,
                'has_previous': self.has_previous,
                'page_size': self.page_size
            }
        })
```

### 3. 缓存策略

#### Redis缓存配置

```python
# Django缓存配置
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/1',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'SERIALIZER': 'django_redis.serializers.json.JSONSerializer',
            'COMPRESSOR': 'django_redis.compressors.zlib.ZlibCompressor',
        },
        'KEY_PREFIX': 'points_system',
        'TIMEOUT': 300,  # 5分钟默认过期
    }
}

# 缓存装饰器使用
from django.core.cache import cache
from functools import wraps

def cache_result(timeout=300, key_func=None):
    """结果缓存装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 生成缓存键
            if key_func:
                cache_key = key_func(*args, **kwargs)
            else:
                cache_key = f"{func.__name__}:{hash(str(args) + str(kwargs))}"
            
            # 尝试从缓存获取
            result = cache.get(cache_key)
            if result is not None:
                return result
            
            # 执行函数并缓存结果
            result = func(*args, **kwargs)
            cache.set(cache_key, result, timeout)
            
            return result
        return wrapper
    return decorator

# 使用示例
@cache_result(timeout=600, key_func=lambda tenant_id: f"user_levels:{tenant_id}")
def get_user_levels(tenant_id):
    return UserLevel.objects.filter(tenant_id=tenant_id, is_active=True)
```

---

## 🔒 安全最佳实践

### 1. 输入验证和清理

```python
import re
from django.core.validators import validate_email
from django.core.exceptions import ValidationError

class SecurityValidator:
    """安全验证器"""
    
    @staticmethod
    def validate_points_amount(amount):
        """验证积分数量"""
        if not isinstance(amount, int):
            raise ValidationError("积分数量必须是整数")
        
        if amount <= 0:
            raise ValidationError("积分数量必须大于0")
        
        if amount > 100000:
            raise ValidationError("单次积分数量不能超过100000")
        
        return amount
    
    @staticmethod
    def validate_reason(reason):
        """验证操作原因"""
        if not reason:
            return reason
        
        # 移除危险字符
        dangerous_chars = ['<', '>', '"', "'", '&', '\n', '\r']
        cleaned_reason = reason
        
        for char in dangerous_chars:
            cleaned_reason = cleaned_reason.replace(char, '')
        
        # 长度限制
        if len(cleaned_reason) > 500:
            cleaned_reason = cleaned_reason[:500]
        
        return cleaned_reason.strip()
    
    @staticmethod
    def validate_category(category):
        """验证积分类别"""
        valid_categories = [
            'login', 'license', 'referral', 'community', 
            'payment', 'manual', 'vip_upgrade', 'feature_unlock'
        ]
        
        if category not in valid_categories:
            raise ValidationError(f"无效的积分类别: {category}")
        
        return category

# 在序列化器中使用
class PointsOperationSerializer(serializers.Serializer):
    points_amount = serializers.IntegerField(
        validators=[SecurityValidator.validate_points_amount]
    )
    reason = serializers.CharField(
        required=False,
        allow_blank=True,
        validators=[SecurityValidator.validate_reason]
    )
    category = serializers.CharField(
        validators=[SecurityValidator.validate_category]
    )
```

### 2. 权限控制

```python
class SecurePermissionMixin:
    """安全权限混入类"""
    
    def check_tenant_access(self, request, obj):
        """检查租户访问权限"""
        user_tenant = getattr(request.user, 'tenant', None)
        
        if not user_tenant:
            return False
        
        # 检查对象的租户归属
        obj_tenant = getattr(obj, 'tenant', None)
        if obj_tenant and obj_tenant != user_tenant:
            return False
        
        return True
    
    def check_points_operation_permission(self, request, operation_type):
        """检查积分操作权限"""
        from points.services.permission_service import TenantAwarePermissionService
        
        user_tenant = getattr(request.user, 'tenant', None)
        if not user_tenant:
            return False
        
        permissions = TenantAwarePermissionService.get_effective_permissions(
            request.user, user_tenant
        )
        
        permission_map = {
            'earn': 'can_earn_points',
            'spend': 'can_spend_points', 
            'adjust': 'can_adjust_points',
            'manage': 'can_manage_points'
        }
        
        required_permission = permission_map.get(operation_type)
        return permissions.get(required_permission, False)

class SecurePointsViewSet(SecurePermissionMixin, viewsets.ModelViewSet):
    """安全的积分视图集"""
    
    def perform_create(self, serializer):
        # 检查创建权限
        if not self.check_points_operation_permission(self.request, 'earn'):
            raise PermissionDenied("没有积分操作权限")
        
        # 审计日志
        self.log_operation(
            action='points_earn',
            user=self.request.user,
            data=serializer.validated_data
        )
        
        super().perform_create(serializer)
    
    def log_operation(self, action, user, data):
        """记录操作日志"""
        from common.models import AuditLog
        
        AuditLog.objects.create(
            action=action,
            user=user,
            ip_address=self.get_client_ip(),
            user_agent=self.request.META.get('HTTP_USER_AGENT', ''),
            data=data,
            timestamp=timezone.now()
        )
    
    def get_client_ip(self):
        """获取客户端IP"""
        x_forwarded_for = self.request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = self.request.META.get('REMOTE_ADDR')
        return ip
```

### 3. 数据加密

```python
from cryptography.fernet import Fernet
from django.conf import settings

class DataEncryption:
    """数据加密工具"""
    
    def __init__(self):
        self.cipher_suite = Fernet(settings.ENCRYPTION_KEY.encode())
    
    def encrypt_sensitive_data(self, data):
        """加密敏感数据"""
        if not data:
            return data
        
        encrypted_data = self.cipher_suite.encrypt(data.encode())
        return encrypted_data.decode()
    
    def decrypt_sensitive_data(self, encrypted_data):
        """解密敏感数据"""
        if not encrypted_data:
            return encrypted_data
        
        decrypted_data = self.cipher_suite.decrypt(encrypted_data.encode())
        return decrypted_data.decode()

# 在模型中使用
class EncryptedUserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    _encrypted_email = models.TextField()  # 存储加密的邮箱
    _encrypted_phone = models.TextField()  # 存储加密的手机号
    
    encryption = DataEncryption()
    
    @property
    def email(self):
        return self.encryption.decrypt_sensitive_data(self._encrypted_email)
    
    @email.setter
    def email(self, value):
        self._encrypted_email = self.encryption.encrypt_sensitive_data(value)
    
    @property
    def phone(self):
        return self.encryption.decrypt_sensitive_data(self._encrypted_phone)
    
    @phone.setter
    def phone(self, value):
        self._encrypted_phone = self.encryption.encrypt_sensitive_data(value)
```

---

## 📊 监控和调试

### 1. 日志记录

```python
import logging
import json
from datetime import datetime

# 配置结构化日志
class StructuredLogger:
    def __init__(self, name):
        self.logger = logging.getLogger(name)
    
    def log_api_request(self, request, response_time=None, status_code=None):
        """记录API请求日志"""
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'type': 'api_request',
            'method': request.method,
            'path': request.path,
            'user_id': getattr(request.user, 'id', None),
            'tenant_id': getattr(request.user, 'tenant_id', None),
            'ip_address': self.get_client_ip(request),
            'user_agent': request.META.get('HTTP_USER_AGENT', ''),
            'response_time_ms': response_time,
            'status_code': status_code
        }
        
        self.logger.info(json.dumps(log_data))
    
    def log_business_event(self, event_type, user_id, tenant_id, details):
        """记录业务事件日志"""
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'type': 'business_event',
            'event_type': event_type,
            'user_id': user_id,
            'tenant_id': tenant_id,
            'details': details
        }
        
        self.logger.info(json.dumps(log_data))
    
    def log_error(self, error, context=None):
        """记录错误日志"""
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'type': 'error',
            'error_message': str(error),
            'error_type': type(error).__name__,
            'context': context or {}
        }
        
        self.logger.error(json.dumps(log_data))

# 中间件记录请求
class LoggingMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        self.logger = StructuredLogger('api_requests')
    
    def __call__(self, request):
        start_time = time.time()
        
        response = self.get_response(request)
        
        response_time = (time.time() - start_time) * 1000
        
        self.logger.log_api_request(
            request=request,
            response_time=response_time,
            status_code=response.status_code
        )
        
        return response
```

### 2. 性能监控

```python
import time
from functools import wraps
from django.core.cache import cache

class PerformanceMonitor:
    """性能监控器"""
    
    @staticmethod
    def track_execution_time(func_name=None):
        """追踪函数执行时间"""
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                start_time = time.time()
                
                try:
                    result = func(*args, **kwargs)
                    execution_time = (time.time() - start_time) * 1000
                    
                    # 记录性能指标
                    PerformanceMonitor.record_metric(
                        metric_name=func_name or func.__name__,
                        value=execution_time,
                        metric_type='execution_time'
                    )
                    
                    return result
                except Exception as e:
                    execution_time = (time.time() - start_time) * 1000
                    
                    # 记录错误执行时间
                    PerformanceMonitor.record_metric(
                        metric_name=f"{func_name or func.__name__}_error",
                        value=execution_time,
                        metric_type='error_execution_time'
                    )
                    
                    raise
            
            return wrapper
        return decorator
    
    @staticmethod
    def record_metric(metric_name, value, metric_type='counter'):
        """记录性能指标"""
        cache_key = f"metrics:{metric_name}:{int(time.time() // 60)}"  # 按分钟聚合
        
        current_data = cache.get(cache_key, {
            'count': 0,
            'total': 0,
            'min': float('inf'),
            'max': 0,
            'type': metric_type
        })
        
        current_data['count'] += 1
        current_data['total'] += value
        current_data['min'] = min(current_data['min'], value)
        current_data['max'] = max(current_data['max'], value)
        current_data['avg'] = current_data['total'] / current_data['count']
        
        cache.set(cache_key, current_data, 300)  # 5分钟过期

# 使用装饰器
@PerformanceMonitor.track_execution_time('points_calculation')
def calculate_user_points(user_id, tenant_id):
    """计算用户积分"""
    # 复杂的积分计算逻辑
    pass
```

### 3. 健康检查

```python
from django.http import JsonResponse
from django.db import connections
from django.core.cache import cache

def health_check(request):
    """系统健康检查"""
    health_status = {
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat(),
        'services': {}
    }
    
    # 数据库连接检查
    try:
        db_conn = connections['default']
        db_conn.ensure_connection()
        health_status['services']['database'] = {
            'status': 'healthy',
            'response_time_ms': 0  # 可以测量实际响应时间
        }
    except Exception as e:
        health_status['services']['database'] = {
            'status': 'unhealthy',
            'error': str(e)
        }
        health_status['status'] = 'unhealthy'
    
    # Redis缓存检查
    try:
        cache.set('health_check', 'ok', 10)
        if cache.get('health_check') == 'ok':
            health_status['services']['redis'] = {'status': 'healthy'}
        else:
            raise Exception("Cache read/write failed")
    except Exception as e:
        health_status['services']['redis'] = {
            'status': 'unhealthy',
            'error': str(e)
        }
        health_status['status'] = 'unhealthy'
    
    # API服务状态
    health_status['services']['api'] = {
        'status': 'healthy',
        'version': '1.0.0'
    }
    
    status_code = 200 if health_status['status'] == 'healthy' else 503
    return JsonResponse(health_status, status=status_code)
```

---

## 🚀 部署和运维

### 1. 环境配置

```python
# settings/production.py
import os
from .base import *

# 安全设置
DEBUG = False
ALLOWED_HOSTS = os.environ.get('ALLOWED_HOSTS', '').split(',')

# 数据库配置
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.environ.get('DB_NAME'),
        'USER': os.environ.get('DB_USER'),
        'PASSWORD': os.environ.get('DB_PASSWORD'),
        'HOST': os.environ.get('DB_HOST', 'localhost'),
        'PORT': os.environ.get('DB_PORT', '5432'),
        'OPTIONS': {
            'MAX_CONNS': 20
        }
    }
}

# Redis配置
REDIS_URL = os.environ.get('REDIS_URL', 'redis://localhost:6379')

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': REDIS_URL,
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'CONNECTION_POOL_KWARGS': {
                'max_connections': 50,
                'retry_on_timeout': True
            }
        }
    }
}

# 日志配置
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'json': {
            '()': 'pythonjsonlogger.jsonlogger.JsonFormatter',
            'format': '%(levelname)s %(asctime)s %(module)s %(message)s'
        }
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/var/log/points_system/app.log',
            'maxBytes': 1024*1024*10,  # 10MB
            'backupCount': 5,
            'formatter': 'json'
        },
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'verbose'
        }
    },
    'loggers': {
        'django': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
        },
        'points': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
        }
    }
}

# 安全配置
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
X_FRAME_OPTIONS = 'DENY'
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

# API限流
REST_FRAMEWORK['DEFAULT_THROTTLE_RATES'] = {
    'anon': '100/hour',
    'user': '1000/hour',
    'points_operations': '500/hour'
}
```

### 2. Docker部署

```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    build-essential \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# 安装Python依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建非root用户
RUN useradd --create-home --shell /bin/bash app
RUN chown -R app:app /app
USER app

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "--workers", "4", "core.wsgi:application"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_DB: points_system
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  web:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DEBUG=False
      - DB_HOST=db
      - DB_NAME=points_system
      - DB_USER=postgres
      - DB_PASSWORD=password
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis
    volumes:
      - ./logs:/var/log/points_system

volumes:
  postgres_data:
  redis_data:
```

### 3. 监控和告警

```python
# monitoring/metrics.py
import time
from prometheus_client import Counter, Histogram, Gauge

# Prometheus指标
api_requests_total = Counter(
    'api_requests_total',
    'Total API requests',
    ['method', 'endpoint', 'status']
)

api_request_duration = Histogram(
    'api_request_duration_seconds',
    'API request duration in seconds',
    ['method', 'endpoint']
)

points_operations_total = Counter(
    'points_operations_total',
    'Total points operations',
    ['operation_type', 'status']
)

active_users_gauge = Gauge(
    'active_users_total',
    'Number of active users'
)

class MetricsMiddleware:
    """Prometheus指标中间件"""
    
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        start_time = time.time()
        
        response = self.get_response(request)
        
        # 记录请求指标
        duration = time.time() - start_time
        
        api_requests_total.labels(
            method=request.method,
            endpoint=request.path,
            status=response.status_code
        ).inc()
        
        api_request_duration.labels(
            method=request.method,
            endpoint=request.path
        ).observe(duration)
        
        return response

# monitoring/alerts.py
class AlertManager:
    """告警管理器"""
    
    def __init__(self):
        self.alert_channels = {
            'email': self.send_email_alert,
            'slack': self.send_slack_alert,
            'sms': self.send_sms_alert
        }
    
    def check_system_health(self):
        """检查系统健康状态"""
        alerts = []
        
        # 检查API响应时间
        avg_response_time = self.get_avg_response_time()
        if avg_response_time > 1000:  # 1秒
            alerts.append({
                'type': 'performance',
                'severity': 'warning',
                'message': f'API平均响应时间过高: {avg_response_time}ms'
            })
        
        # 检查错误率
        error_rate = self.get_error_rate()
        if error_rate > 0.05:  # 5%
            alerts.append({
                'type': 'error_rate',
                'severity': 'critical',
                'message': f'API错误率过高: {error_rate*100:.2f}%'
            })
        
        # 检查数据库连接
        if not self.check_database_health():
            alerts.append({
                'type': 'database',
                'severity': 'critical',
                'message': '数据库连接异常'
            })
        
        # 发送告警
        for alert in alerts:
            self.send_alert(alert)
    
    def send_alert(self, alert):
        """发送告警"""
        severity = alert['severity']
        
        if severity == 'critical':
            channels = ['email', 'sms', 'slack']
        elif severity == 'warning':
            channels = ['email', 'slack']
        else:
            channels = ['slack']
        
        for channel in channels:
            try:
                self.alert_channels[channel](alert)
            except Exception as e:
                logger.error(f"发送{channel}告警失败: {e}")
```

---

## 📝 总结

### 关键最佳实践要点

1. **错误处理**
   - 统一错误响应格式
   - 合理的HTTP状态码
   - 详细的错误信息和解决建议
   - 客户端重试机制

2. **性能优化**
   - 数据库查询优化
   - 适当的缓存策略
   - API响应优化
   - 批量操作支持

3. **安全防护**
   - 输入验证和清理
   - 权限控制和审计
   - 敏感数据加密
   - 安全配置强化

4. **监控运维**
   - 结构化日志记录
   - 性能指标监控
   - 健康检查机制
   - 告警和通知系统

通过遵循这些最佳实践，可以构建一个稳定、安全、高性能的多租户积分系统API。

---

## 🎓 学习资源

- **官方文档**: Django REST Framework 文档
- **最佳实践**: RESTful API 设计指南
- **安全指南**: OWASP API Security Top 10
- **性能优化**: Python Web 应用性能优化指南
- **监控运维**: Prometheus + Grafana 监控实践

---

**🎉 至此，多租户积分系统API文档编写完成！**
