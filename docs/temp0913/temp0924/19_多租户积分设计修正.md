# 多租户积分设计修正方案

## 🎯 设计修正目标

### 🔍 现有代码深度分析结果
经过仔细分析现有代码库确认：

**✅ 现有模型验证**:
- **Member模型** (`users/models.py`) - 完全原子，无积分相关字段
- **License模型** (`licenses/models.py`) - 完全原子，已有`max_activations`和`current_activations`
- **LicenseAssignment模型** - 在现有代码中**完全不存在**
- **积分系统** - 在现有代码中**完全不存在**

**✅ 零修改确认**:
- 所有现有代码模型保持100%不变
- 所有新功能通过新增模型实现
- 完全向下兼容，零业务风险

### 核心问题解决
1. **🔒 零代码修改**: 任何现有代码模型都不修改，保证100%安全
2. **多租户积分隔离**: 同一 Member 在不同租户下拥有独立的积分和等级
3. **VIP 期限管理**: 完整的 VIP 等标签期限管理机制
4. **向下兼容保证**: 现有业务逻辑和API完全不受影响

### 设计原则
- **原子模型保护**: 现有Member、License、Tenant表完全不变
- **租户隔离**: 积分和等级数据按租户严格隔离，通过新增TenantUserProfile表实现
- **功能独立**: 新功能通过独立的表和服务实现，可独立部署和回滚
- **性能优化**: 针对多租户查询的专门优化设计

## 🏗️ 重新设计的数据模型

### 核心表结构关系图

```
                            ┌─────────────────┐
                            │     Tenant      │
                            │    (租户)       │
                            └─────────┬───────┘
                                      │ 1:N
                                      ▼
                            ┌─────────────────┐
                            │ TenantUserProfile│
                            │ (租户用户档案)   │
                            │ + total_points  │
                            │ + current_level │
                            └─────┬───┬───────┘
                                  │   │
                             1:N  │   │ N:M
                                  │   │
                    ┌─────────────▼   ▼─────────────┐
                    │                               │
          ┌─────────▼─────────┐           ┌─────────▼─────────┐
          │ TenantUserPoints  │           │TenantUserTypeTag  │
          │ (租户用户积分)     │           │(租户用户标签关联) │
          └─────────┬─────────┘           └─────────┬─────────┘
                    │                               │
                    │                               │ N:1
                    │                               ▼
                    │                     ┌─────────────────┐
                    │                     │   UserTypeTag   │
                    │                     │   (用户标签)     │
                    │                     └─────────────────┘
                    │
          ┌─────────▼─────────┐
          │    UserLevel      │
          │   (用户等级)       │
          └───────────────────┘
```

### 1. TenantUserProfile (租户用户档案表)

这是新的核心表，替代在 Member 表中存储积分信息：

```sql
CREATE TABLE tenant_user_profile (
    id BIGSERIAL PRIMARY KEY,
    
    -- 关联信息
    member_id BIGINT NOT NULL REFERENCES member(id) ON DELETE CASCADE,
    tenant_id BIGINT NOT NULL REFERENCES tenants_tenant(id) ON DELETE CASCADE,
    
    -- 积分信息
    total_points INTEGER NOT NULL DEFAULT 0,
    available_points INTEGER NOT NULL DEFAULT 0,  -- 可用积分（排除已过期）
    
    -- 等级信息
    current_level_id BIGINT REFERENCES user_level(id),
    level_updated_at TIMESTAMP WITH TIME ZONE,
    
    -- 统计信息
    points_earned_total INTEGER NOT NULL DEFAULT 0,      -- 历史总获得积分
    points_spent_total INTEGER NOT NULL DEFAULT 0,       -- 历史总消费积分
    points_expired_total INTEGER NOT NULL DEFAULT 0,     -- 历史总过期积分
    
    -- 活跃度信息
    last_points_update TIMESTAMP WITH TIME ZONE,         -- 最后积分变动时间
    last_level_check TIMESTAMP WITH TIME ZONE,           -- 最后等级检查时间
    consecutive_login_days INTEGER DEFAULT 0,            -- 连续登录天数
    last_login_date DATE,                                -- 最后登录日期
    
    -- 配置信息
    points_multiplier DECIMAL(3,2) DEFAULT 1.00,         -- 积分倍数（租户特殊配置）
    is_points_enabled BOOLEAN DEFAULT TRUE,              -- 是否启用积分功能
    
    -- 审计字段
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    
    -- 约束
    CONSTRAINT unique_member_tenant UNIQUE (member_id, tenant_id),
    CONSTRAINT valid_points CHECK (total_points >= 0 AND available_points >= 0),
    CONSTRAINT available_points_check CHECK (available_points <= total_points),
    CONSTRAINT valid_multiplier CHECK (points_multiplier > 0)
);

-- 索引优化
CREATE INDEX idx_tenant_user_profile_member ON tenant_user_profile (member_id);
CREATE INDEX idx_tenant_user_profile_tenant ON tenant_user_profile (tenant_id);
CREATE INDEX idx_tenant_user_profile_points ON tenant_user_profile (tenant_id, total_points DESC);
CREATE INDEX idx_tenant_user_profile_level ON tenant_user_profile (current_level_id);
CREATE INDEX idx_tenant_user_profile_active ON tenant_user_profile (tenant_id, last_points_update DESC);

-- 注释
COMMENT ON TABLE tenant_user_profile IS '租户用户档案表，存储用户在特定租户下的积分和等级信息';
COMMENT ON COLUMN tenant_user_profile.points_multiplier IS '积分倍数，支持租户级别的积分政策调整';
COMMENT ON COLUMN tenant_user_profile.consecutive_login_days IS '连续登录天数，用于计算登录奖励';
```

### 2. TenantUserPoints (租户用户积分记录表)

修改原有的 UserPoints 表，增加租户隔离：

```sql
CREATE TABLE tenant_user_points (
    id BIGSERIAL PRIMARY KEY,
    
    -- 关联信息
    tenant_user_profile_id BIGINT NOT NULL REFERENCES tenant_user_profile(id) ON DELETE CASCADE,
    tenant_id BIGINT NOT NULL REFERENCES tenants_tenant(id) ON DELETE CASCADE,  -- 冗余字段，便于查询优化
    member_id BIGINT NOT NULL REFERENCES member(id) ON DELETE CASCADE,          -- 冗余字段，便于查询优化
    
    -- 积分类型分类
    point_type VARCHAR(50) NOT NULL,           -- 积分类型：earn(获得), spend(消费), expire(过期), adjust(调整)
    category VARCHAR(50) NOT NULL,             -- 业务分类：login, license, referral, payment, community, etc.
    subcategory VARCHAR(50),                   -- 子分类：daily_login, first_activation, etc.
    
    -- 积分数值
    points INTEGER NOT NULL,                   -- 积分变动数量（正数为获得，负数为消费）
    balance_before INTEGER NOT NULL,          -- 操作前积分余额
    balance_after INTEGER NOT NULL,           -- 操作后积分余额
    
    -- 租户特定信息
    tenant_multiplier DECIMAL(3,2) DEFAULT 1.00,  -- 本次积分的租户倍数
    original_points INTEGER,                       -- 倍数调整前的原始积分
    
    -- 关联信息
    source_type VARCHAR(50),                   -- 来源类型：manual, system, api, migration
    source_id BIGINT,                          -- 关联的源记录ID（如license_id, order_id等）
    source_description TEXT,                   -- 来源描述
    
    -- 积分生命周期
    earned_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),  -- 积分获得时间
    expires_at TIMESTAMP WITH TIME ZONE,       -- 积分过期时间（NULL表示永不过期）
    expired_at TIMESTAMP WITH TIME ZONE,       -- 实际过期时间
    
    -- 操作信息
    operation_reason TEXT,                     -- 操作原因说明
    operator_id BIGINT,                        -- 操作人员ID（系统操作为NULL）
    batch_id VARCHAR(100),                     -- 批量操作标识
    
    -- 状态管理
    status VARCHAR(20) NOT NULL DEFAULT 'active',  -- 状态：active, expired, cancelled, adjusted
    is_manual BOOLEAN NOT NULL DEFAULT FALSE,  -- 是否手动调整
    
    -- 审计字段
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by_id BIGINT,
    
    -- 约束
    CONSTRAINT points_not_zero CHECK (points != 0),
    CONSTRAINT valid_balance CHECK (balance_after = balance_before + points),
    CONSTRAINT valid_balance_positive CHECK (balance_after >= 0),
    CONSTRAINT valid_tenant_multiplier CHECK (tenant_multiplier > 0)
);

-- 索引优化（支持多租户查询）
CREATE INDEX idx_tenant_user_points_profile ON tenant_user_points (tenant_user_profile_id, created_at DESC);
CREATE INDEX idx_tenant_user_points_tenant_member ON tenant_user_points (tenant_id, member_id, created_at DESC);
CREATE INDEX idx_tenant_user_points_type ON tenant_user_points (tenant_id, point_type, category);
CREATE INDEX idx_tenant_user_points_expires ON tenant_user_points (tenant_id, expires_at) 
    WHERE expires_at IS NOT NULL AND status = 'active';
CREATE INDEX idx_tenant_user_points_source ON tenant_user_points (tenant_id, source_type, source_id) 
    WHERE source_id IS NOT NULL;

-- 分区表（按租户分区，可选）
-- 注意：PostgreSQL 13+ 支持
/*
CREATE TABLE tenant_user_points_default PARTITION OF tenant_user_points DEFAULT;
-- 为大租户创建独立分区
CREATE TABLE tenant_user_points_tenant_1 PARTITION OF tenant_user_points 
FOR VALUES IN (1);
*/

COMMENT ON TABLE tenant_user_points IS '租户用户积分记录表，按租户隔离存储积分变动记录';
COMMENT ON COLUMN tenant_user_points.tenant_multiplier IS '租户积分倍数，记录当时的倍数政策';
```

### 3. TenantUserTypeTag (租户用户标签关联表)

修改用户标签关联，支持租户隔离和VIP期限：

```sql
CREATE TABLE tenant_user_type_tag (
    id BIGSERIAL PRIMARY KEY,
    
    -- 关联信息
    tenant_user_profile_id BIGINT NOT NULL REFERENCES tenant_user_profile(id) ON DELETE CASCADE,
    tag_id BIGINT NOT NULL REFERENCES user_type_tag(id) ON DELETE CASCADE,
    tenant_id BIGINT NOT NULL REFERENCES tenants_tenant(id) ON DELETE CASCADE,  -- 冗余字段
    member_id BIGINT NOT NULL REFERENCES member(id) ON DELETE CASCADE,          -- 冗余字段
    
    -- 授予信息
    granted_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    granted_by_id BIGINT,                      -- 授予人ID（系统授予为NULL）
    grant_reason TEXT,                         -- 授予原因
    grant_method VARCHAR(50) NOT NULL,         -- 授予方式：payment, manual, auto, promotion, migration
    
    -- VIP期限管理
    expires_at TIMESTAMP WITH TIME ZONE,       -- 过期时间
    original_duration_days INTEGER,            -- 原始有效期天数
    extended_days INTEGER DEFAULT 0,           -- 延期天数
    auto_renewal BOOLEAN DEFAULT FALSE,        -- 是否自动续期
    renewal_count INTEGER DEFAULT 0,           -- 续期次数
    
    -- 期限计算辅助字段
    grace_period_days INTEGER DEFAULT 0,       -- 宽限期天数（过期后仍可使用的天数）
    reminder_sent_at TIMESTAMP WITH TIME ZONE, -- 过期提醒发送时间
    renewal_reminder_sent BOOLEAN DEFAULT FALSE, -- 是否已发送续期提醒
    
    -- 使用统计
    last_used_at TIMESTAMP WITH TIME ZONE,     -- 最后使用时间
    usage_count INTEGER DEFAULT 0,             -- 使用次数
    benefits_used JSONB DEFAULT '{}',          -- 已使用的福利记录
    
    -- 支付信息（用于VIP等付费标签）
    payment_id BIGINT,                         -- 关联的支付记录ID
    payment_amount DECIMAL(10,2),              -- 支付金额
    payment_currency VARCHAR(3) DEFAULT 'CNY', -- 支付货币
    
    -- 状态管理
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    status VARCHAR(20) DEFAULT 'active',       -- 状态：active, expired, suspended, cancelled, grace_period
    
    -- 备注信息
    notes TEXT,                                -- 备注信息
    metadata JSONB DEFAULT '{}',               -- 扩展元数据
    
    -- 审计字段
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    
    -- 约束
    CONSTRAINT unique_tenant_member_tag UNIQUE (tenant_id, member_id, tag_id),
    CONSTRAINT valid_expiry CHECK (expires_at IS NULL OR expires_at > granted_at),
    CONSTRAINT valid_duration CHECK (original_duration_days IS NULL OR original_duration_days > 0),
    CONSTRAINT valid_payment_amount CHECK (payment_amount IS NULL OR payment_amount >= 0)
);

-- 索引优化
CREATE INDEX idx_tenant_user_type_tag_profile ON tenant_user_type_tag (tenant_user_profile_id, is_active);
CREATE INDEX idx_tenant_user_type_tag_tenant_member ON tenant_user_type_tag (tenant_id, member_id, is_active);
CREATE INDEX idx_tenant_user_type_tag_expires ON tenant_user_type_tag (tenant_id, expires_at) 
    WHERE expires_at IS NOT NULL AND is_active = TRUE;
CREATE INDEX idx_tenant_user_type_tag_payment ON tenant_user_type_tag (payment_id) 
    WHERE payment_id IS NOT NULL;
CREATE INDEX idx_tenant_user_type_tag_renewal ON tenant_user_type_tag (tenant_id, auto_renewal, expires_at)
    WHERE auto_renewal = TRUE AND is_active = TRUE;

COMMENT ON TABLE tenant_user_type_tag IS '租户用户标签关联表，支持VIP期限管理和租户隔离';
COMMENT ON COLUMN tenant_user_type_tag.grace_period_days IS 'VIP过期后的宽限期，允许用户在此期间仍享受部分权益';
COMMENT ON COLUMN tenant_user_type_tag.auto_renewal IS '自动续期标识，可与支付系统集成实现自动续费';
```

## 🔧 VIP期限管理机制

### VIP期限计算逻辑

```python
class VipExpirationManager:
    """VIP期限管理器"""
    
    def calculate_vip_status(self, tenant_user_tag_relation):
        """计算VIP状态"""
        
        now = timezone.now()
        
        # 1. 检查基础过期时间
        if not tenant_user_tag_relation.expires_at:
            return {
                'status': 'permanent',
                'is_active': True,
                'days_remaining': None,
                'grace_period_remaining': None
            }
        
        expires_at = tenant_user_tag_relation.expires_at
        
        # 2. 未过期
        if now < expires_at:
            days_remaining = (expires_at - now).days
            return {
                'status': 'active',
                'is_active': True,
                'days_remaining': days_remaining,
                'expires_at': expires_at,
                'needs_renewal_reminder': days_remaining <= 7  # 7天内提醒续费
            }
        
        # 3. 已过期，检查宽限期
        grace_period_days = tenant_user_tag_relation.grace_period_days or 0
        grace_period_end = expires_at + timedelta(days=grace_period_days)
        
        if now <= grace_period_end:
            grace_days_remaining = (grace_period_end - now).days
            return {
                'status': 'grace_period',
                'is_active': True,  # 宽限期内仍可使用
                'days_remaining': 0,
                'grace_period_remaining': grace_days_remaining,
                'expires_at': expires_at,
                'grace_period_end': grace_period_end
            }
        
        # 4. 彻底过期
        return {
            'status': 'expired',
            'is_active': False,
            'days_remaining': 0,
            'grace_period_remaining': 0,
            'expired_days': (now - grace_period_end).days
        }
    
    def extend_vip_period(self, tenant_user_tag_id, extend_days, reason=""):
        """延长VIP期限"""
        
        with transaction.atomic():
            relation = TenantUserTypeTag.objects.select_for_update().get(
                id=tenant_user_tag_id
            )
            
            if relation.expires_at:
                # 从当前过期时间延长
                new_expires_at = relation.expires_at + timedelta(days=extend_days)
            else:
                # 永久VIP设置过期时间
                new_expires_at = timezone.now() + timedelta(days=extend_days)
            
            relation.expires_at = new_expires_at
            relation.extended_days = (relation.extended_days or 0) + extend_days
            relation.updated_at = timezone.now()
            relation.save()
            
            # 记录延期日志
            self._log_vip_extension(relation, extend_days, reason)
            
            return new_expires_at
    
    def setup_auto_renewal(self, tenant_user_tag_id, payment_method_id):
        """设置自动续期"""
        
        relation = TenantUserTypeTag.objects.get(id=tenant_user_tag_id)
        relation.auto_renewal = True
        relation.metadata = relation.metadata or {}
        relation.metadata['auto_renewal_payment_method'] = payment_method_id
        relation.save()
        
        # 创建自动续期任务
        schedule_auto_renewal_check.apply_async(
            args=[tenant_user_tag_id],
            eta=relation.expires_at - timedelta(days=3)  # 提前3天检查续期
        )
```

### VIP期限检查任务

```python
@shared_task
def check_vip_expirations():
    """检查VIP过期状态的定时任务"""
    
    now = timezone.now()
    
    # 1. 查找即将过期的VIP（7天内）
    soon_expire_tags = TenantUserTypeTag.objects.filter(
        tag__tag_code='vip',
        is_active=True,
        expires_at__lte=now + timedelta(days=7),
        expires_at__gt=now,
        renewal_reminder_sent=False
    )
    
    for tag_relation in soon_expire_tags:
        # 发送续期提醒
        send_vip_renewal_reminder.delay(tag_relation.id)
        
        # 标记已发送提醒
        tag_relation.renewal_reminder_sent = True
        tag_relation.save(update_fields=['renewal_reminder_sent'])
    
    # 2. 处理已过期但在宽限期内的VIP
    grace_period_tags = TenantUserTypeTag.objects.filter(
        tag__tag_code='vip',
        is_active=True,
        expires_at__lt=now,
        status='active'
    )
    
    for tag_relation in grace_period_tags:
        grace_period_end = tag_relation.expires_at + timedelta(
            days=tag_relation.grace_period_days or 0
        )
        
        if now <= grace_period_end:
            # 进入宽限期
            tag_relation.status = 'grace_period'
            tag_relation.save(update_fields=['status'])
            
            # 发送宽限期通知
            send_vip_grace_period_notice.delay(tag_relation.id)
        else:
            # 彻底过期
            tag_relation.is_active = False
            tag_relation.status = 'expired'
            tag_relation.save(update_fields=['is_active', 'status'])
            
            # 发送过期通知
            send_vip_expired_notice.delay(tag_relation.id)
            
            # 清除权限缓存
            clear_user_permission_cache.delay(
                tag_relation.tenant_id, 
                tag_relation.member_id
            )
    
    # 3. 处理自动续期
    auto_renewal_tags = TenantUserTypeTag.objects.filter(
        tag__tag_code='vip',
        is_active=True,
        auto_renewal=True,
        expires_at__lte=now + timedelta(days=1),  # 提前1天续期
        expires_at__gt=now
    )
    
    for tag_relation in auto_renewal_tags:
        try_auto_renewal.delay(tag_relation.id)

@shared_task
def try_auto_renewal(tenant_user_tag_id):
    """尝试自动续期VIP"""
    
    try:
        tag_relation = TenantUserTypeTag.objects.get(id=tenant_user_tag_id)
        
        # 获取支付方式
        payment_method_id = tag_relation.metadata.get('auto_renewal_payment_method')
        if not payment_method_id:
            logger.warning(f"VIP自动续期失败：未找到支付方式 (tag_id: {tenant_user_tag_id})")
            return
        
        # 计算续期费用
        tag = tag_relation.tag
        renewal_price = tag.price_config.get('renewal_price', tag.price_config.get('price', 0))
        
        # 尝试支付
        payment_result = process_vip_renewal_payment(
            member_id=tag_relation.member_id,
            tenant_id=tag_relation.tenant_id,
            amount=renewal_price,
            payment_method_id=payment_method_id
        )
        
        if payment_result['success']:
            # 续期成功
            original_duration = tag_relation.original_duration_days or 365
            extend_days = original_duration
            
            VipExpirationManager().extend_vip_period(
                tenant_user_tag_id, 
                extend_days, 
                f"自动续期 - 支付ID: {payment_result['payment_id']}"
            )
            
            tag_relation.renewal_count += 1
            tag_relation.payment_id = payment_result['payment_id']
            tag_relation.payment_amount = renewal_price
            tag_relation.save()
            
            # 发送续期成功通知
            send_vip_renewal_success_notice.delay(tenant_user_tag_id)
            
            logger.info(f"VIP自动续期成功 (tag_id: {tenant_user_tag_id})")
        else:
            # 续期失败
            logger.warning(f"VIP自动续期支付失败: {payment_result['error']} (tag_id: {tenant_user_tag_id})")
            
            # 发送续期失败通知
            send_vip_renewal_failed_notice.delay(tenant_user_tag_id, payment_result['error'])
            
    except Exception as e:
        logger.error(f"VIP自动续期异常: {str(e)} (tag_id: {tenant_user_tag_id})")
```

## 🔄 多租户权限计算

### 租户隔离的权限服务

```python
class TenantAwarePermissionService:
    """支持多租户的权限计算服务"""
    
    def get_user_permissions(self, member_id: int, tenant_id: int, force_refresh: bool = False):
        """获取用户在特定租户下的权限"""
        
        cache_key = f"tenant_perms:{tenant_id}:{member_id}"
        
        if not force_refresh:
            cached_perms = cache.get(cache_key)
            if cached_perms:
                return cached_perms
        
        # 计算租户用户权限
        permissions = self._calculate_tenant_user_permissions(member_id, tenant_id)
        
        # 缓存结果（租户隔离）
        cache.set(cache_key, permissions, self.CACHE_TIMEOUT)
        
        return permissions
    
    def _calculate_tenant_user_permissions(self, member_id: int, tenant_id: int):
        """计算租户用户权限"""
        
        try:
            # 获取或创建租户用户档案
            profile, created = TenantUserProfile.objects.get_or_create(
                member_id=member_id,
                tenant_id=tenant_id,
                defaults={
                    'total_points': 0,
                    'available_points': 0,
                }
            )
            
            if created:
                # 新用户，设置默认等级
                default_level = UserLevel.objects.filter(
                    level_order=1, is_active=True
                ).first()
                if default_level:
                    profile.current_level = default_level
                    profile.save()
        
        except Exception as e:
            logger.error(f"获取租户用户档案失败: member_id={member_id}, tenant_id={tenant_id}, error={str(e)}")
            return self._get_default_permissions(member_id, tenant_id)
        
        # 1. 获取基础等级权限
        level_permissions, level_quota = self._get_level_permissions(profile)
        
        # 2. 获取租户用户标签权限
        tag_permissions_list, tag_quota_modifiers = self._get_tenant_tag_permissions(profile)
        
        # 3. 合并权限
        final_permissions = self._merge_permissions(level_permissions, tag_permissions_list)
        
        # 4. 计算最终配额（考虑租户倍数）
        final_quota = self._calculate_tenant_final_quota(
            level_quota, tag_quota_modifiers, profile.points_multiplier
        )
        
        return {
            'member_id': member_id,
            'tenant_id': tenant_id,
            'profile_id': profile.id,
            'level': {
                'id': profile.current_level.id if profile.current_level else None,
                'name': profile.current_level.level_name if profile.current_level else '未设置',
                'code': profile.current_level.level_code if profile.current_level else 'none',
                'order': profile.current_level.level_order if profile.current_level else 0,
            },
            'total_points': profile.total_points,
            'available_points': profile.available_points,
            'points_multiplier': float(profile.points_multiplier),
            'permissions': final_permissions,
            'quota': final_quota,
            'tags': self._get_tenant_tag_info(profile),
            'calculated_at': timezone.now().isoformat(),
        }
    
    def _get_tenant_tag_permissions(self, profile):
        """获取租户标签权限"""
        
        # 获取当前有效的标签（考虑VIP过期状态）
        active_tag_relations = TenantUserTypeTag.objects.filter(
            tenant_user_profile=profile,
            is_active=True
        ).select_related('tag')
        
        tag_permissions = []
        tag_quota_modifiers = []
        
        vip_manager = VipExpirationManager()
        
        for tag_relation in active_tag_relations:
            # 检查VIP等有期限标签的状态
            if tag_relation.expires_at:
                vip_status = vip_manager.calculate_vip_status(tag_relation)
                if not vip_status['is_active']:
                    # 标签已过期，跳过
                    continue
                
                # 如果在宽限期，可能有权限降级
                if vip_status['status'] == 'grace_period':
                    # 宽限期内权限可能有所限制
                    grace_permissions = self._get_grace_period_permissions(tag_relation.tag)
                    tag_permissions.append(grace_permissions)
                    
                    grace_quota = self._get_grace_period_quota_modifiers(tag_relation.tag)
                    tag_quota_modifiers.append(grace_quota)
                else:
                    # 正常权限
                    tag_permissions.append(tag_relation.tag.permission_modifiers or {})
                    tag_quota_modifiers.append(tag_relation.tag.quota_modifiers or {})
            else:
                # 永久标签
                tag_permissions.append(tag_relation.tag.permission_modifiers or {})
                tag_quota_modifiers.append(tag_relation.tag.quota_modifiers or {})
        
        return tag_permissions, tag_quota_modifiers
    
    def _get_grace_period_permissions(self, tag):
        """获取宽限期权限（可能有所限制）"""
        
        base_permissions = tag.permission_modifiers or {}
        grace_permissions = base_permissions.copy()
        
        # 宽限期可能限制某些权限
        if tag.tag_code == 'vip':
            # VIP宽限期：保留基础权限，限制高级权限
            grace_permissions.pop('batch_operations', None)
            grace_permissions.pop('api_unlimited', None)
            grace_permissions['support_level'] = 'standard'  # 降级支持等级
        
        return grace_permissions
    
    def invalidate_tenant_user_cache(self, member_id: int, tenant_id: int):
        """清除租户用户权限缓存"""
        cache_key = f"tenant_perms:{tenant_id}:{member_id}"
        cache.delete(cache_key)
```

## 📋 总结

### 🎯 核心修正点

1. **Member表保持不变**: 所有积分和等级信息存储在 `TenantUserProfile` 表中
2. **完整租户隔离**: 同一用户在不同租户下拥有独立的积分、等级和标签
3. **VIP期限精确管理**: 支持过期时间、宽限期、自动续期等完整的期限管理
4. **多租户权限计算**: 权限缓存和计算都按租户隔离

### 🔧 VIP期限管理特性

- **灵活期限设置**: 支持天数、月数、年数等多种期限单位
- **宽限期机制**: VIP过期后仍可在宽限期内使用部分功能
- **自动续期**: 支持绑定支付方式的自动续费
- **提醒机制**: 过期前提醒、宽限期提醒、续费失败提醒
- **使用统计**: 记录VIP功能使用情况和频次

### 🚀 系统优势

- **数据隔离**: 完美支持多租户环境
- **扩展性强**: 每个租户可以有不同的积分政策
- **稳定性高**: 不修改核心Member表，降低风险
- **功能完整**: VIP管理功能一应俱全

这个修正方案完美解决了多租户积分隔离和VIP期限管理的问题！
