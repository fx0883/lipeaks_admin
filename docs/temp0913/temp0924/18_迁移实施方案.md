# 迁移实施方案

## 🎯 迁移目标与策略

### 迁移目标
- **零停机迁移**: 业务无感知升级到新的统一等级系统
- **数据完整性**: 确保现有用户数据和权限不丢失
- **平滑过渡**: 用户体验连续，权限逐步优化
- **快速回滚**: 遇到问题能够快速回到原系统

### 迁移策略
- **分阶段实施**: 分4个阶段逐步迁移，每阶段可独立验证
- **灰度发布**: 先在小部分用户中测试，逐步扩大范围
- **双系统并行**: 新旧系统并行运行一段时间，确保稳定性
- **数据同步**: 实时同步关键数据，保证一致性

## 📅 详细实施计划

### 第一阶段：基础设施建设 (第1-2周)

#### Week 1: 数据模型创建

##### Day 1-2: 创建新表结构
```sql
-- 1. 创建用户等级表
CREATE TABLE user_level (
    -- 完整表结构见数据模型设计文档
);

-- 插入初始等级数据
INSERT INTO user_level (level_name, level_code, level_order, min_points, max_points, ...) VALUES
('青铜', 'bronze', 1, 0, 999, ...),
('白银', 'silver', 2, 1000, 2999, ...),
-- ... 其他等级

-- 2. 创建用户标签表
CREATE TABLE user_type_tag (
    -- 完整表结构
);

-- 插入初始标签数据
INSERT INTO user_type_tag (tag_name, tag_code, tag_category, ...) VALUES
('VIP用户', 'vip', 'payment', ...),
('企业用户', 'enterprise', 'business', ...),
-- ... 其他标签

-- 3. 创建积分记录表
CREATE TABLE user_points (
    -- 完整表结构
);

-- 4. 创建用户标签关联表
CREATE TABLE member_type_tag (
    -- 完整表结构
);
```

##### Day 3-4: 扩展现有Member表
```sql
-- 为Member表添加新字段
ALTER TABLE member ADD COLUMN total_points INTEGER NOT NULL DEFAULT 0;
ALTER TABLE member ADD COLUMN available_points INTEGER NOT NULL DEFAULT 0;
ALTER TABLE member ADD COLUMN current_level_id BIGINT REFERENCES user_level(id);
ALTER TABLE member ADD COLUMN level_updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW();

-- 创建必要索引
CREATE INDEX idx_member_total_points ON member (total_points DESC);
CREATE INDEX idx_member_level ON member (current_level_id);

-- 添加约束
ALTER TABLE member ADD CONSTRAINT valid_points CHECK (total_points >= 0 AND available_points >= 0);
```

##### Day 5: 验证数据结构
```python
# 验证脚本
def validate_table_structure():
    """验证新建表结构的完整性"""
    
    # 检查表是否存在
    tables_to_check = ['user_level', 'user_type_tag', 'user_points', 'member_type_tag']
    for table in tables_to_check:
        assert table_exists(table), f"表 {table} 不存在"
    
    # 检查字段完整性
    member_fields = get_table_fields('member')
    required_fields = ['total_points', 'available_points', 'current_level_id', 'level_updated_at']
    for field in required_fields:
        assert field in member_fields, f"Member表缺少字段 {field}"
    
    # 检查索引
    indexes = get_table_indexes('member')
    required_indexes = ['idx_member_total_points', 'idx_member_level']
    for index in required_indexes:
        assert index in indexes, f"缺少索引 {index}"
    
    print("✅ 数据结构验证通过")
```

#### Week 2: 核心服务开发

##### Day 1-2: 开发积分服务
```python
# 实现积分管理核心服务
class PointsService:
    def add_points(self, member_id, points, category, **kwargs):
        """添加积分的核心实现"""
        pass
    
    def spend_points(self, member_id, points, category, **kwargs):
        """消费积分的核心实现"""
        pass
    
    def calculate_available_points(self, member_id):
        """计算用户可用积分"""
        pass

# 编写单元测试
class TestPointsService(TestCase):
    def test_add_points_success(self):
        """测试成功添加积分"""
        pass
    
    def test_spend_points_insufficient(self):
        """测试积分不足的情况"""
        pass
```

##### Day 3-4: 开发权限服务
```python
# 实现权限计算核心服务
class PermissionService:
    def get_user_permissions(self, member_id, force_refresh=False):
        """获取用户完整权限"""
        pass
    
    def check_permission(self, member_id, permission_key):
        """检查特定权限"""
        pass
    
    def invalidate_cache(self, member_id):
        """清除权限缓存"""
        pass

# 性能测试
def test_permission_calculation_performance():
    """测试权限计算性能"""
    start_time = time.time()
    for i in range(1000):
        permissions = PermissionService().get_user_permissions(test_user_id)
    end_time = time.time()
    
    avg_time = (end_time - start_time) / 1000
    assert avg_time < 0.01, f"权限计算平均耗时 {avg_time:.3f}s 超过10ms限制"
```

##### Day 5: 集成测试和优化
```python
# 集成测试套件
class IntegrationTestSuite:
    def test_points_to_level_flow(self):
        """测试积分到等级的完整流程"""
        # 1. 用户获得积分
        result = PointsService().add_points(user_id, 1000, 'login')
        assert result['success']
        
        # 2. 检查等级是否自动更新
        user = Member.objects.get(id=user_id)
        assert user.current_level.level_code == 'silver'
        
        # 3. 检查权限是否更新
        permissions = PermissionService().get_user_permissions(user_id)
        assert permissions['level']['code'] == 'silver'
        
        # 4. 检查许可证配额是否更新
        assert permissions['quota']['max_licenses'] == 5
```

### 第二阶段：数据迁移准备 (第3周)

#### 现有数据分析与映射

##### Day 1-2: 现有用户类型数据分析
```python
# 数据分析脚本
def analyze_existing_user_types():
    """分析现有用户类型分布"""
    
    # 统计现有用户类型分布
    user_type_stats = Member.objects.values('user_type_id').annotate(
        count=Count('id')
    ).order_by('-count')
    
    print("现有用户类型分布：")
    for stat in user_type_stats:
        user_type = UserType.objects.get(id=stat['user_type_id']) if stat['user_type_id'] else None
        print(f"  {user_type.name if user_type else '未设置'}: {stat['count']} 用户")
    
    # 分析用户行为数据
    active_users = Member.objects.filter(
        last_login__gte=timezone.now() - timedelta(days=30)
    ).count()
    
    license_users = Member.objects.filter(
        license_assignments__isnull=False
    ).distinct().count()
    
    print(f"活跃用户 (30天内): {active_users}")
    print(f"持有许可证用户: {license_users}")
    
    return {
        'user_type_distribution': user_type_stats,
        'active_users': active_users,
        'license_users': license_users
    }

# 创建迁移映射表
USER_TYPE_TO_TAG_MAPPING = {
    1: 'vip',        # 原VIP用户 -> VIP标签
    2: 'enterprise', # 原企业用户 -> 企业标签
    3: 'education',  # 原教育用户 -> 教育标签
    # 其他类型暂不映射，用户保持一般用户等级
}
```

##### Day 3-4: 积分计算策略制定
```python
def calculate_historical_points(member_id):
    """根据历史行为计算用户应有积分"""
    
    member = Member.objects.get(id=member_id)
    total_points = 0
    point_records = []
    
    # 1. 注册时间积分 (基础积分)
    days_since_registration = (timezone.now().date() - member.created_at.date()).days
    registration_points = min(days_since_registration * 5, 500)  # 最多500分
    total_points += registration_points
    point_records.append({
        'category': 'registration',
        'points': registration_points,
        'description': '注册时长奖励'
    })
    
    # 2. 许可证活动积分
    license_assignments = member.license_assignments.filter(
        is_deleted=False
    ).count()
    license_points = license_assignments * 50  # 每个许可证50分
    total_points += license_points
    point_records.append({
        'category': 'license_activity',
        'points': license_points,
        'description': f'许可证申请活动 ({license_assignments}个)'
    })
    
    # 3. 登录活跃度积分
    # 假设根据最后登录时间推算活跃度
    if member.last_login:
        days_since_login = (timezone.now() - member.last_login).days
        if days_since_login <= 7:
            activity_points = 200  # 高活跃
        elif days_since_login <= 30:
            activity_points = 100  # 中活跃
        else:
            activity_points = 50   # 低活跃
        
        total_points += activity_points
        point_records.append({
            'category': 'activity',
            'points': activity_points,
            'description': '用户活跃度奖励'
        })
    
    # 4. 付费用户额外积分
    if hasattr(member, 'payment_records'):
        payment_total = member.payment_records.aggregate(
            total=Sum('amount')
        )['total'] or 0
        payment_points = int(payment_total * 5)  # 每元5分
        total_points += payment_points
        point_records.append({
            'category': 'payment',
            'points': payment_points,
            'description': f'历史付费奖励 (¥{payment_total})'
        })
    
    return {
        'total_points': total_points,
        'point_breakdown': point_records,
        'recommended_level': UserLevel.get_level_by_points(total_points)
    }
```

##### Day 5: 迁移脚本开发
```python
def migrate_user_data_dry_run():
    """数据迁移预演（不实际修改数据）"""
    
    migration_stats = {
        'total_users': 0,
        'users_with_points': 0,
        'users_with_tags': 0,
        'level_distribution': {},
        'tag_distribution': {},
        'errors': []
    }
    
    for member in Member.objects.all():
        try:
            migration_stats['total_users'] += 1
            
            # 计算积分
            point_data = calculate_historical_points(member.id)
            if point_data['total_points'] > 0:
                migration_stats['users_with_points'] += 1
                
                # 统计等级分布
                level_code = point_data['recommended_level'].level_code
                migration_stats['level_distribution'][level_code] = \
                    migration_stats['level_distribution'].get(level_code, 0) + 1
            
            # 检查标签映射
            if member.user_type_id in USER_TYPE_TO_TAG_MAPPING:
                migration_stats['users_with_tags'] += 1
                tag_code = USER_TYPE_TO_TAG_MAPPING[member.user_type_id]
                migration_stats['tag_distribution'][tag_code] = \
                    migration_stats['tag_distribution'].get(tag_code, 0) + 1
                    
        except Exception as e:
            migration_stats['errors'].append({
                'member_id': member.id,
                'error': str(e)
            })
    
    print("迁移预演结果：")
    print(f"  总用户数: {migration_stats['total_users']}")
    print(f"  将获得积分的用户: {migration_stats['users_with_points']}")
    print(f"  将获得标签的用户: {migration_stats['users_with_tags']}")
    print(f"  等级分布: {migration_stats['level_distribution']}")
    print(f"  标签分布: {migration_stats['tag_distribution']}")
    print(f"  错误数量: {len(migration_stats['errors'])}")
    
    return migration_stats
```

### 第三阶段：灰度迁移实施 (第4-5周)

#### Week 4: 小规模灰度测试

##### Day 1-2: 选择灰度用户群体
```python
def select_gray_users(percentage=5):
    """选择灰度测试用户（5%用户）"""
    
    # 选择策略：
    # 1. 活跃用户优先
    # 2. 不同用户类型均匀分布
    # 3. 包含部分新用户和老用户
    
    total_users = Member.objects.count()
    gray_user_count = max(int(total_users * percentage / 100), 10)  # 至少10个用户
    
    # 按活跃度和用户类型分层采样
    gray_users = []
    
    # 1. 选择活跃用户 (50%)
    active_users = Member.objects.filter(
        last_login__gte=timezone.now() - timedelta(days=7)
    ).order_by('?')[:gray_user_count // 2]
    gray_users.extend(active_users)
    
    # 2. 选择老用户 (30%)
    old_users = Member.objects.filter(
        created_at__lte=timezone.now() - timedelta(days=90)
    ).exclude(id__in=[u.id for u in gray_users]).order_by('?')[:gray_user_count * 3 // 10]
    gray_users.extend(old_users)
    
    # 3. 选择新用户 (20%)
    new_users = Member.objects.filter(
        created_at__gte=timezone.now() - timedelta(days=30)
    ).exclude(id__in=[u.id for u in gray_users]).order_by('?')[:gray_user_count - len(gray_users)]
    gray_users.extend(new_users)
    
    # 标记灰度用户
    gray_user_ids = [u.id for u in gray_users]
    
    # 创建灰度标记（临时方案）
    cache.set('gray_users_v1', gray_user_ids, timeout=30*24*60*60)  # 30天过期
    
    print(f"选择了 {len(gray_users)} 个灰度用户")
    return gray_user_ids

def is_gray_user(member_id):
    """判断是否为灰度用户"""
    gray_users = cache.get('gray_users_v1', [])
    return member_id in gray_users
```

##### Day 3-4: 灰度用户数据迁移
```python
@transaction.atomic
def migrate_gray_users():
    """迁移灰度用户数据"""
    
    gray_user_ids = cache.get('gray_users_v1', [])
    if not gray_user_ids:
        raise ValueError("未找到灰度用户列表")
    
    migration_results = {
        'success_count': 0,
        'error_count': 0,
        'errors': []
    }
    
    for member_id in gray_user_ids:
        try:
            migrate_single_user(member_id)
            migration_results['success_count'] += 1
            
        except Exception as e:
            migration_results['error_count'] += 1
            migration_results['errors'].append({
                'member_id': member_id,
                'error': str(e)
            })
            logger.error(f"迁移用户 {member_id} 失败: {str(e)}")
    
    print(f"灰度迁移完成: 成功 {migration_results['success_count']}, 失败 {migration_results['error_count']}")
    return migration_results

def migrate_single_user(member_id):
    """迁移单个用户的数据"""
    
    member = Member.objects.get(id=member_id)
    
    # 1. 计算并设置积分
    point_data = calculate_historical_points(member_id)
    
    if point_data['total_points'] > 0:
        # 创建初始积分记录
        UserPoints.objects.create(
            member=member,
            point_type='earn',
            category='migration',
            subcategory='historical_data',
            points=point_data['total_points'],
            balance_before=0,
            balance_after=point_data['total_points'],
            operation_reason='历史数据迁移初始积分',
            source_type='migration',
            is_manual=True
        )
        
        # 更新用户积分
        member.total_points = point_data['total_points']
        member.available_points = point_data['total_points']
    
    # 2. 设置用户等级
    if point_data['recommended_level']:
        member.current_level = point_data['recommended_level']
        member.level_updated_at = timezone.now()
    
    # 3. 迁移用户类型到标签
    if member.user_type_id in USER_TYPE_TO_TAG_MAPPING:
        tag_code = USER_TYPE_TO_TAG_MAPPING[member.user_type_id]
        tag = UserTypeTag.objects.get(tag_code=tag_code)
        
        MemberTypeTag.objects.create(
            member=member,
            tag=tag,
            grant_method='migration',
            grant_reason='从原用户类型迁移',
            is_active=True
        )
    
    member.save()
    
    # 4. 清除权限缓存，强制重新计算
    cache.delete(f'user_perms:{member_id}')
    
    logger.info(f"用户 {member_id} 迁移完成: 积分={point_data['total_points']}, 等级={point_data['recommended_level'].level_name if point_data['recommended_level'] else '无'}")
```

##### Day 5: 灰度效果监控
```python
def monitor_gray_migration():
    """监控灰度迁移效果"""
    
    gray_user_ids = cache.get('gray_users_v1', [])
    
    # 1. 权限计算性能监控
    permission_times = []
    for user_id in gray_user_ids[:100]:  # 采样100个用户
        start_time = time.time()
        PermissionService().get_user_permissions(user_id)
        end_time = time.time()
        permission_times.append(end_time - start_time)
    
    avg_permission_time = sum(permission_times) / len(permission_times)
    max_permission_time = max(permission_times)
    
    # 2. 数据一致性检查
    consistency_errors = []
    for user_id in gray_user_ids:
        try:
            member = Member.objects.get(id=user_id)
            
            # 检查积分和等级一致性
            expected_level = UserLevel.get_level_by_points(member.total_points)
            if member.current_level != expected_level:
                consistency_errors.append({
                    'user_id': user_id,
                    'error': f'等级不一致: 期望{expected_level}, 实际{member.current_level}'
                })
            
            # 检查可用积分计算
            calculated_available = calculate_available_points(user_id)
            if abs(member.available_points - calculated_available) > 0:
                consistency_errors.append({
                    'user_id': user_id,
                    'error': f'可用积分不一致: 期望{calculated_available}, 实际{member.available_points}'
                })
                
        except Exception as e:
            consistency_errors.append({
                'user_id': user_id,
                'error': f'检查失败: {str(e)}'
            })
    
    # 3. 用户反馈收集
    feedback_stats = {
        'positive': 0,
        'negative': 0,
        'neutral': 0
    }
    
    # 这里可以集成用户反馈系统的数据
    
    print("灰度迁移监控报告：")
    print(f"  权限计算平均耗时: {avg_permission_time:.3f}s")
    print(f"  权限计算最大耗时: {max_permission_time:.3f}s")
    print(f"  数据一致性错误: {len(consistency_errors)} 个")
    print(f"  用户反馈: 正面{feedback_stats['positive']} 中性{feedback_stats['neutral']} 负面{feedback_stats['negative']}")
    
    # 判断是否可以继续全量迁移
    migration_ready = (
        avg_permission_time < 0.1 and  # 权限计算平均耗时<100ms
        max_permission_time < 0.5 and  # 最大耗时<500ms
        len(consistency_errors) < len(gray_user_ids) * 0.01 and  # 错误率<1%
        feedback_stats['negative'] < feedback_stats['positive']  # 正面反馈多于负面
    )
    
    return {
        'migration_ready': migration_ready,
        'performance': {'avg': avg_permission_time, 'max': max_permission_time},
        'consistency_errors': consistency_errors,
        'feedback': feedback_stats
    }
```

#### Week 5: 灰度范围扩大

##### Day 1-3: 扩大到20%用户
```python
def expand_gray_migration(target_percentage=20):
    """扩大灰度范围到20%用户"""
    
    current_gray_users = cache.get('gray_users_v1', [])
    total_users = Member.objects.count()
    target_count = int(total_users * target_percentage / 100)
    additional_needed = target_count - len(current_gray_users)
    
    if additional_needed <= 0:
        print("当前灰度用户数量已足够")
        return current_gray_users
    
    # 选择额外的用户
    additional_users = Member.objects.exclude(
        id__in=current_gray_users
    ).order_by('?')[:additional_needed]
    
    # 迁移新增用户
    for member in additional_users:
        try:
            migrate_single_user(member.id)
            current_gray_users.append(member.id)
        except Exception as e:
            logger.error(f"迁移用户 {member.id} 失败: {str(e)}")
    
    # 更新灰度用户列表
    cache.set('gray_users_v1', current_gray_users, timeout=30*24*60*60)
    
    print(f"灰度范围扩大完成，当前灰度用户数: {len(current_gray_users)}")
    return current_gray_users
```

##### Day 4-5: 双系统兼容性验证
```python
def validate_dual_system_compatibility():
    """验证双系统兼容性"""
    
    gray_users = cache.get('gray_users_v1', [])
    validation_results = {
        'permission_consistency': [],
        'quota_consistency': [],
        'api_compatibility': [],
        'performance_comparison': []
    }
    
    for user_id in gray_users[:50]:  # 采样验证
        try:
            # 1. 权限一致性验证
            old_permissions = get_legacy_user_permissions(user_id)
            new_permissions = PermissionService().get_user_permissions(user_id)
            
            # 比较关键权限
            key_permissions = ['license_request', 'api_access', 'batch_operations']
            for perm in key_permissions:
                old_value = old_permissions.get(perm, False)
                new_value = new_permissions['permissions'].get(perm, False)
                
                if old_value != new_value:
                    validation_results['permission_consistency'].append({
                        'user_id': user_id,
                        'permission': perm,
                        'old_value': old_value,
                        'new_value': new_value
                    })
            
            # 2. 配额一致性验证
            old_quota = get_legacy_user_quota(user_id)
            new_quota = new_permissions['quota']
            
            if old_quota.get('max_licenses', 0) > new_quota.get('max_licenses', 0):
                validation_results['quota_consistency'].append({
                    'user_id': user_id,
                    'old_quota': old_quota['max_licenses'],
                    'new_quota': new_quota['max_licenses']
                })
            
            # 3. API兼容性测试
            api_test_result = test_user_api_compatibility(user_id)
            if not api_test_result['success']:
                validation_results['api_compatibility'].append({
                    'user_id': user_id,
                    'error': api_test_result['error']
                })
                
        except Exception as e:
            logger.error(f"验证用户 {user_id} 兼容性失败: {str(e)}")
    
    # 生成兼容性报告
    compatibility_score = calculate_compatibility_score(validation_results)
    
    print(f"双系统兼容性验证完成，兼容性评分: {compatibility_score:.2f}/100")
    
    return {
        'compatibility_score': compatibility_score,
        'validation_results': validation_results,
        'ready_for_full_migration': compatibility_score >= 95
    }
```

### 第四阶段：全量迁移 (第6-7周)

#### Week 6: 全量数据迁移

##### Day 1-2: 全量迁移准备
```python
def prepare_full_migration():
    """全量迁移准备工作"""
    
    # 1. 数据备份
    backup_result = create_full_backup()
    if not backup_result['success']:
        raise Exception(f"数据备份失败: {backup_result['error']}")
    
    # 2. 系统资源检查
    system_check = check_system_resources()
    if not system_check['ready']:
        raise Exception(f"系统资源不足: {system_check['issues']}")
    
    # 3. 迁移任务队列准备
    setup_migration_queue()
    
    # 4. 监控系统准备
    setup_migration_monitoring()
    
    # 5. 回滚方案准备
    prepare_rollback_plan()
    
    print("全量迁移准备工作完成")
    return True

def create_full_backup():
    """创建完整数据备份"""
    backup_tables = [
        'member', 'user_type', 'license_assignment', 
        'user_points', 'user_level', 'user_type_tag', 'member_type_tag'
    ]
    
    backup_timestamp = timezone.now().strftime('%Y%m%d_%H%M%S')
    backup_path = f"/backups/migration_backup_{backup_timestamp}"
    
    try:
        for table in backup_tables:
            subprocess.run([
                'pg_dump', 
                '--table', table,
                '--data-only',
                '--file', f"{backup_path}/{table}.sql",
                settings.DATABASES['default']['NAME']
            ], check=True)
        
        return {'success': True, 'backup_path': backup_path}
    except subprocess.CalledProcessError as e:
        return {'success': False, 'error': str(e)}
```

##### Day 3-4: 批量迁移执行
```python
@shared_task(bind=True)
def batch_migrate_users(self, user_ids_batch):
    """批量迁移用户数据的异步任务"""
    
    batch_size = len(user_ids_batch)
    success_count = 0
    error_count = 0
    errors = []
    
    for i, user_id in enumerate(user_ids_batch):
        try:
            # 更新任务进度
            self.update_state(
                state='PROGRESS',
                meta={
                    'current': i + 1,
                    'total': batch_size,
                    'status': f'迁移用户 {user_id}'
                }
            )
            
            migrate_single_user(user_id)
            success_count += 1
            
        except Exception as e:
            error_count += 1
            errors.append({'user_id': user_id, 'error': str(e)})
            logger.error(f"迁移用户 {user_id} 失败: {str(e)}")
    
    return {
        'batch_size': batch_size,
        'success_count': success_count,
        'error_count': error_count,
        'errors': errors
    }

def execute_full_migration():
    """执行全量迁移"""
    
    # 获取所有待迁移用户
    gray_users = cache.get('gray_users_v1', [])
    all_users = Member.objects.exclude(id__in=gray_users).values_list('id', flat=True)
    
    batch_size = 100  # 每批处理100个用户
    batches = [all_users[i:i+batch_size] for i in range(0, len(all_users), batch_size)]
    
    # 启动异步迁移任务
    migration_tasks = []
    for batch in batches:
        task = batch_migrate_users.delay(list(batch))
        migration_tasks.append(task)
    
    print(f"启动了 {len(migration_tasks)} 个迁移任务，共 {len(all_users)} 个用户")
    
    # 监控迁移进度
    monitor_migration_progress(migration_tasks)
    
    return migration_tasks

def monitor_migration_progress(migration_tasks):
    """监控迁移进度"""
    
    while True:
        completed_tasks = 0
        total_success = 0
        total_errors = 0
        
        for task in migration_tasks:
            if task.ready():
                completed_tasks += 1
                if task.successful():
                    result = task.result
                    total_success += result['success_count']
                    total_errors += result['error_count']
        
        progress = completed_tasks / len(migration_tasks) * 100
        
        print(f"迁移进度: {progress:.1f}% ({completed_tasks}/{len(migration_tasks)} 批次完成)")
        print(f"成功: {total_success}, 失败: {total_errors}")
        
        if completed_tasks == len(migration_tasks):
            break
        
        time.sleep(30)  # 每30秒检查一次
    
    print("全量迁移完成！")
```

##### Day 5: 数据验证和修复
```python
def validate_and_fix_migration():
    """验证迁移结果并修复问题"""
    
    validation_report = {
        'total_users': Member.objects.count(),
        'migrated_users': Member.objects.exclude(total_points=0).count(),
        'data_issues': [],
        'fixed_issues': 0
    }
    
    # 1. 检查积分和等级一致性
    inconsistent_users = Member.objects.extra(
        where=["""
            current_level_id != (
                SELECT id FROM user_level 
                WHERE min_points <= total_points 
                AND (max_points IS NULL OR total_points <= max_points)
                AND is_active = true
                ORDER BY level_order DESC 
                LIMIT 1
            )
        """]
    )
    
    for member in inconsistent_users:
        correct_level = UserLevel.get_level_by_points(member.total_points)
        if correct_level:
            member.current_level = correct_level
            member.level_updated_at = timezone.now()
            member.save()
            validation_report['fixed_issues'] += 1
        else:
            validation_report['data_issues'].append({
                'user_id': member.id,
                'issue': f'无法为积分 {member.total_points} 找到对应等级'
            })
    
    # 2. 检查可用积分计算
    for member in Member.objects.filter(available_points__gt=0):
        calculated_available = calculate_available_points(member.id)
        if abs(member.available_points - calculated_available) > 0:
            member.available_points = calculated_available
            member.save()
            validation_report['fixed_issues'] += 1
    
    # 3. 检查权限缓存一致性
    cache_issues = 0
    for member_id in Member.objects.values_list('id', flat=True):
        try:
            # 清除并重新计算权限缓存
            cache.delete(f'user_perms:{member_id}')
            PermissionService().get_user_permissions(member_id)
        except Exception as e:
            validation_report['data_issues'].append({
                'user_id': member_id,
                'issue': f'权限计算失败: {str(e)}'
            })
            cache_issues += 1
    
    print(f"数据验证完成: 修复了 {validation_report['fixed_issues']} 个问题")
    print(f"剩余问题: {len(validation_report['data_issues'])} 个")
    
    return validation_report
```

## 🔒 风险控制与回滚方案

### 关键风险点识别

#### 1. 数据风险
```python
# 数据丢失风险控制
class DataProtectionManager:
    
    def create_checkpoint(self, checkpoint_name):
        """创建数据检查点"""
        checkpoint = {
            'name': checkpoint_name,
            'timestamp': timezone.now(),
            'data_checksums': {},
            'record_counts': {}
        }
        
        # 记录关键表的数据校验和
        critical_tables = ['member', 'user_points', 'member_type_tag']
        for table in critical_tables:
            checkpoint['record_counts'][table] = self.get_table_count(table)
            checkpoint['data_checksums'][table] = self.calculate_table_checksum(table)
        
        # 保存检查点
        cache.set(f'checkpoint:{checkpoint_name}', checkpoint, timeout=7*24*60*60)
        return checkpoint
    
    def validate_checkpoint(self, checkpoint_name):
        """验证数据检查点"""
        checkpoint = cache.get(f'checkpoint:{checkpoint_name}')
        if not checkpoint:
            raise ValueError(f"检查点 {checkpoint_name} 不存在")
        
        validation_result = {'valid': True, 'issues': []}
        
        for table in checkpoint['record_counts']:
            current_count = self.get_table_count(table)
            expected_count = checkpoint['record_counts'][table]
            
            if current_count < expected_count:
                validation_result['valid'] = False
                validation_result['issues'].append({
                    'table': table,
                    'issue': f'记录数量减少: {expected_count} -> {current_count}'
                })
        
        return validation_result
```

#### 2. 性能风险
```python
# 性能监控和保护
class PerformanceMonitor:
    
    def __init__(self):
        self.metrics = {
            'permission_calc_times': [],
            'db_query_times': [],
            'cache_hit_rates': [],
            'api_response_times': []
        }
    
    def monitor_permission_performance(self):
        """监控权限计算性能"""
        sample_users = Member.objects.order_by('?')[:100]
        
        for user in sample_users:
            start_time = time.time()
            PermissionService().get_user_permissions(user.id)
            end_time = time.time()
            
            calc_time = end_time - start_time
            self.metrics['permission_calc_times'].append(calc_time)
            
            # 如果单次计算超过1秒，立即告警
            if calc_time > 1.0:
                logger.critical(f"权限计算性能告警: 用户 {user.id} 耗时 {calc_time:.3f}s")
        
        avg_time = sum(self.metrics['permission_calc_times']) / len(self.metrics['permission_calc_times'])
        
        if avg_time > 0.1:  # 平均耗时超过100ms
            return {'status': 'warning', 'avg_time': avg_time}
        else:
            return {'status': 'ok', 'avg_time': avg_time}
```

### 快速回滚方案

#### 1. 数据回滚
```python
def emergency_rollback():
    """紧急数据回滚"""
    
    print("开始紧急回滚...")
    
    try:
        with transaction.atomic():
            # 1. 恢复Member表字段
            Member.objects.update(
                total_points=0,
                available_points=0,
                current_level_id=None,
                level_updated_at=None
            )
            
            # 2. 清空新增的表
            UserPoints.objects.all().delete()
            MemberTypeTag.objects.all().delete()
            
            # 3. 清除所有权限缓存
            cache.clear()
            
            # 4. 恢复原有的用户类型权限逻辑
            restore_legacy_permission_system()
            
        print("紧急回滚完成")
        return {'success': True}
        
    except Exception as e:
        print(f"紧急回滚失败: {str(e)}")
        return {'success': False, 'error': str(e)}

def restore_legacy_permission_system():
    """恢复原有权限系统"""
    
    # 重新启用原有的权限检查逻辑
    # 这里需要根据具体的原系统实现来编写
    
    # 示例：恢复原有的配置文件
    legacy_config = {
        'permission_system': 'legacy',
        'use_new_level_system': False,
        'use_points_system': False
    }
    
    cache.set('system_config', legacy_config, timeout=None)
```

#### 2. 分步回滚
```python
def gradual_rollback(rollback_percentage=10):
    """分步回滚（先回滚部分用户）"""
    
    # 选择回滚用户（从灰度用户开始）
    gray_users = cache.get('gray_users_v1', [])
    rollback_count = min(len(gray_users), int(len(gray_users) * rollback_percentage / 100))
    rollback_users = gray_users[:rollback_count]
    
    rollback_results = {'success_count': 0, 'error_count': 0, 'errors': []}
    
    for user_id in rollback_users:
        try:
            # 回滚单个用户
            member = Member.objects.get(id=user_id)
            
            # 保存原有积分数据（用于恢复）
            original_points = member.total_points
            
            # 重置用户数据
            member.total_points = 0
            member.available_points = 0
            member.current_level_id = None
            member.save()
            
            # 删除积分记录
            member.point_records.all().delete()
            
            # 删除标签关联
            member.tag_relations.all().delete()
            
            # 清除权限缓存
            cache.delete(f'user_perms:{user_id}')
            
            rollback_results['success_count'] += 1
            logger.info(f"用户 {user_id} 回滚成功 (原积分: {original_points})")
            
        except Exception as e:
            rollback_results['error_count'] += 1
            rollback_results['errors'].append({'user_id': user_id, 'error': str(e)})
            logger.error(f"用户 {user_id} 回滚失败: {str(e)}")
    
    # 更新灰度用户列表
    remaining_gray_users = gray_users[rollback_count:]
    cache.set('gray_users_v1', remaining_gray_users, timeout=30*24*60*60)
    
    print(f"分步回滚完成: 成功 {rollback_results['success_count']}, 失败 {rollback_results['error_count']}")
    return rollback_results
```

## 📊 成功标准与验收

### 技术指标
- [ ] **数据完整性**: 迁移后数据丢失率 < 0.01%
- [ ] **性能标准**: 权限计算平均耗时 < 100ms，95%请求 < 500ms
- [ ] **系统稳定性**: 迁移期间系统可用性 > 99.9%
- [ ] **缓存效率**: 权限缓存命中率 > 90%

### 业务指标
- [ ] **用户体验**: 用户操作成功率保持 > 99.5%
- [ ] **功能完整性**: 所有原有功能正常工作
- [ ] **权限准确性**: 用户权限计算错误率 < 0.1%
- [ ] **配额一致性**: 许可证配额分配准确率 100%

### 验收清单
- [ ] 所有用户成功迁移到新系统
- [ ] 原有用户类型正确映射为标签
- [ ] 积分计算和等级分配准确
- [ ] 权限缓存机制正常工作
- [ ] API接口完全兼容
- [ ] 监控和告警系统正常
- [ ] 数据备份和回滚方案验证通过
- [ ] 用户反馈整体积极

---

**总结**: 这个迁移方案通过分阶段、灰度发布的方式，确保了从双重等级系统到统一积分等级系统的平滑过渡。完整的风险控制和回滚机制保障了迁移过程的安全性，详细的监控和验证确保了迁移质量。
