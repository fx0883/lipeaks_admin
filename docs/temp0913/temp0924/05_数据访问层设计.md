# 数据访问层设计

## 🎯 设计目标

### 数据抽象
- **隔离数据实现**: 将数据存储细节从业务逻辑中抽离
- **统一访问接口**: 提供一致的数据访问方式
- **支持多数据源**: 支持不同类型的数据存储

### 性能优化
- **查询优化**: 通过索引和查询策略提升性能
- **缓存集成**: 集成多级缓存机制
- **连接池管理**: 高效的数据库连接管理

## 🏗️ 数据访问架构

```
                    ┌─────────────────────────────────────┐
                    │          数据访问层                  │
                    └─────────────────────────────────────┘
                                    │
            ┌───────────────────────┼───────────────────────┐
            │                       │                       │
   ┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
   │  Repository层   │     │   QuerySet层    │     │   Manager层     │
   │                 │     │                 │     │                 │
   │• 业务查询封装   │     │• 复杂查询构建   │     │• 模型管理       │
   │• 数据访问接口   │     │• 性能优化       │     │• 缓存管理       │
   │• 事务管理       │     │• 分页处理       │     │• 批量操作       │
   └─────────────────┘     └─────────────────┘     └─────────────────┘
            │                       │                       │
            └───────────────────────┼───────────────────────┘
                                    │
                    ┌─────────────────────────────────────┐
                    │           数据存储层                 │
                    │                                     │
                    │  ┌─────────────┐  ┌─────────────┐    │
                    │  │ PostgreSQL  │  │    Redis    │    │
                    │  │   主数据库   │  │    缓存     │    │
                    │  └─────────────┘  └─────────────┘    │
                    └─────────────────────────────────────┘
```

## 📊 Repository模式实现

### 1. 许可证分配仓储 (LicenseAssignmentRepository)

#### 接口设计
```python
# 抽象接口定义
class LicenseAssignmentRepositoryInterface:
    """许可证分配仓储接口"""
    
    # 基础CRUD操作
    def create(self, assignment_data: dict) -> LicenseAssignment
    def get_by_id(self, assignment_id: int) -> LicenseAssignment
    def update(self, assignment_id: int, update_data: dict) -> LicenseAssignment
    def delete(self, assignment_id: int) -> bool
    
    # 业务查询方法
    def find_by_member(self, member_id: int) -> List[LicenseAssignment]
    def find_by_license(self, license_id: int) -> List[LicenseAssignment]
    def find_active_assignments(self, tenant_id: int) -> List[LicenseAssignment]
    def find_expiring_assignments(self, days: int) -> List[LicenseAssignment]
    
    # 统计查询方法
    def count_by_license(self, license_id: int) -> int
    def count_by_member(self, member_id: int) -> int
    def count_by_status(self, status: str, tenant_id: int) -> int
```

#### 具体实现要点

##### 查询优化策略
```python
class LicenseAssignmentRepository(LicenseAssignmentRepositoryInterface):
    
    def find_by_member_with_details(self, member_id: int):
        """查询用户的许可证分配详情 - 优化版本"""
        return LicenseAssignment.objects.select_related(
            'license', 
            'license__product', 
            'license__plan',
            'member',
            'assigned_by'
        ).prefetch_related(
            'license__machine_bindings'
        ).filter(
            member_id=member_id,
            is_deleted=False
        ).order_by('-assigned_at')
    
    def find_expiring_assignments_batch(self, days: int, batch_size: int = 1000):
        """批量查询即将过期的分配记录"""
        from django.utils import timezone
        from datetime import timedelta
        
        expiry_date = timezone.now() + timedelta(days=days)
        
        return LicenseAssignment.objects.filter(
            expires_at__lte=expiry_date,
            status__in=['assigned', 'active'],
            is_deleted=False
        ).select_related('license', 'member').iterator(chunk_size=batch_size)
```

##### 事务处理
```python
from django.db import transaction

class LicenseAssignmentRepository:
    
    @transaction.atomic
    def create_with_audit(self, assignment_data: dict, audit_data: dict):
        """创建分配记录并记录审计日志"""
        # 创建分配记录
        assignment = LicenseAssignment.objects.create(**assignment_data)
        
        # 更新许可证统计
        self._update_license_stats(assignment.license_id)
        
        # 记录审计日志
        self._create_audit_log(assignment.id, audit_data)
        
        return assignment
    
    @transaction.atomic  
    def revoke_with_cleanup(self, assignment_id: int, revoke_reason: str):
        """撤销分配并清理相关数据"""
        assignment = self.get_by_id(assignment_id)
        
        # 更新分配状态
        assignment.status = 'revoked'
        assignment.revoked_at = timezone.now()
        assignment.assignment_notes += f"\n撤销原因: {revoke_reason}"
        assignment.save()
        
        # 清理设备绑定
        self._cleanup_device_bindings(assignment_id)
        
        # 更新许可证统计
        self._update_license_stats(assignment.license_id)
        
        return assignment
```

### 2. 复合查询仓储 (CompositeQueryRepository)

#### 跨表复杂查询
```python
class CompositeQueryRepository:
    """处理跨多个模型的复杂查询"""
    
    def get_user_license_summary(self, member_id: int, tenant_id: int):
        """获取用户许可证使用概览"""
        from django.db.models import Count, Q, Case, When, IntegerField
        
        return LicenseAssignment.objects.filter(
            member_id=member_id,
            license__tenant_id=tenant_id,
            is_deleted=False
        ).aggregate(
            total_licenses=Count('id'),
            active_licenses=Count('id', filter=Q(status='active')),
            expiring_soon=Count('id', filter=Q(
                expires_at__lte=timezone.now() + timedelta(days=30),
                status__in=['assigned', 'active']
            )),
            expired_licenses=Count('id', filter=Q(status='expired'))
        )
    
    def get_license_utilization_report(self, tenant_id: int, date_range: tuple):
        """获取许可证利用率报告"""
        start_date, end_date = date_range
        
        return License.objects.filter(
            tenant_id=tenant_id,
            is_deleted=False
        ).annotate(
            total_assignments=Count('assignments'),
            active_assignments=Count('assignments', filter=Q(
                assignments__status='active',
                assignments__is_deleted=False
            )),
            utilization_rate=Case(
                When(max_activations=0, then=0),
                default=F('active_assignments') * 100 / F('max_activations'),
                output_field=IntegerField()
            )
        ).values(
            'id', 'license_key', 'product__name', 
            'max_activations', 'total_assignments', 
            'active_assignments', 'utilization_rate'
        )
```

## 🔧 自定义Manager和QuerySet

### 1. 许可证分配Manager
```python
class LicenseAssignmentQuerySet(models.QuerySet):
    """许可证分配查询集"""
    
    def active(self):
        """活跃的分配"""
        return self.filter(status__in=['assigned', 'active'], is_deleted=False)
    
    def expired(self):
        """已过期的分配"""
        from django.utils import timezone
        return self.filter(
            Q(expires_at__lt=timezone.now()) | Q(status='expired'),
            is_deleted=False
        )
    
    def expiring_in_days(self, days: int):
        """指定天数内过期的分配"""
        from django.utils import timezone
        from datetime import timedelta
        
        target_date = timezone.now() + timedelta(days=days)
        return self.filter(
            expires_at__lte=target_date,
            expires_at__gt=timezone.now(),
            status__in=['assigned', 'active'],
            is_deleted=False
        )
    
    def by_tenant(self, tenant_id: int):
        """按租户过滤"""
        return self.filter(license__tenant_id=tenant_id)
    
    def with_license_details(self):
        """预加载许可证详情"""
        return self.select_related(
            'license',
            'license__product', 
            'license__plan'
        )
    
    def with_member_details(self):
        """预加载成员详情"""
        return self.select_related('member')

class LicenseAssignmentManager(models.Manager):
    """许可证分配管理器"""
    
    def get_queryset(self):
        return LicenseAssignmentQuerySet(self.model, using=self._db)
    
    def active(self):
        return self.get_queryset().active()
    
    def expired(self):
        return self.get_queryset().expired()
    
    def expiring_in_days(self, days: int):
        return self.get_queryset().expiring_in_days(days)
    
    def by_tenant(self, tenant_id: int):
        return self.get_queryset().by_tenant(tenant_id)
    
    def create_assignment(self, **kwargs):
        """创建分配记录的便捷方法"""
        # 自动设置一些默认值
        if 'assigned_at' not in kwargs:
            kwargs['assigned_at'] = timezone.now()
        
        return self.create(**kwargs)
```

### 2. 扩展现有模型的Manager
```python
class ExtendedLicenseManager(models.Manager):
    """扩展的许可证管理器"""
    
    def with_assignment_stats(self):
        """包含分配统计的许可证查询"""
        from django.db.models import Count, Q
        
        return self.get_queryset().annotate(
            total_assignments=Count('assignments'),
            active_assignments=Count('assignments', filter=Q(
                assignments__status__in=['assigned', 'active'],
                assignments__is_deleted=False
            )),
            available_slots=F('max_activations') - F('active_assignments')
        )
    
    def available_for_assignment(self, tenant_id: int):
        """可用于分配的许可证"""
        return self.with_assignment_stats().filter(
            tenant_id=tenant_id,
            status='activated',
            is_deleted=False,
            available_slots__gt=0
        )

class ExtendedMemberManager(models.Manager):
    """扩展的成员管理器"""
    
    def with_license_count(self):
        """包含许可证数量的成员查询"""
        return self.get_queryset().annotate(
            license_count=Count('license_assignments', filter=Q(
                license_assignments__status__in=['assigned', 'active'],
                license_assignments__is_deleted=False
            ))
        )
    
    def licensed_members(self, tenant_id: int):
        """拥有许可证的成员"""
        return self.filter(
            tenant_id=tenant_id,
            license_assignments__isnull=False,
            license_assignments__status__in=['assigned', 'active'],
            license_assignments__is_deleted=False
        ).distinct()
```

## 📊 缓存策略设计

### 1. 多级缓存架构
```python
class CachedLicenseAssignmentRepository(LicenseAssignmentRepository):
    """带缓存的许可证分配仓储"""
    
    def __init__(self):
        self.cache_timeout = 300  # 5分钟
        self.cache_prefix = 'license_assignment'
    
    def get_by_id(self, assignment_id: int):
        """带缓存的ID查询"""
        cache_key = f"{self.cache_prefix}:assignment:{assignment_id}"
        
        # 尝试从缓存获取
        cached_result = cache.get(cache_key)
        if cached_result:
            return cached_result
        
        # 从数据库查询
        assignment = super().get_by_id(assignment_id)
        
        # 写入缓存
        if assignment:
            cache.set(cache_key, assignment, self.cache_timeout)
        
        return assignment
    
    def find_by_member(self, member_id: int):
        """带缓存的成员许可证查询"""
        cache_key = f"{self.cache_prefix}:member:{member_id}"
        
        cached_result = cache.get(cache_key)
        if cached_result:
            return cached_result
        
        assignments = super().find_by_member(member_id)
        cache.set(cache_key, assignments, self.cache_timeout)
        
        return assignments
    
    def invalidate_cache(self, assignment_id: int = None, member_id: int = None):
        """缓存失效"""
        if assignment_id:
            cache.delete(f"{self.cache_prefix}:assignment:{assignment_id}")
        
        if member_id:
            cache.delete(f"{self.cache_prefix}:member:{member_id}")
```

### 2. 智能缓存更新
```python
class SmartCacheRepository:
    """智能缓存仓储"""
    
    def update_with_cache_invalidation(self, assignment_id: int, update_data: dict):
        """更新数据并智能失效相关缓存"""
        assignment = super().update(assignment_id, update_data)
        
        # 失效直接相关的缓存
        self.invalidate_cache(assignment_id=assignment_id)
        
        # 失效成员相关缓存
        self.invalidate_cache(member_id=assignment.member_id)
        
        # 如果状态发生变化，失效许可证统计缓存
        if 'status' in update_data:
            self._invalidate_license_stats_cache(assignment.license_id)
        
        return assignment
```

## 🔍 查询性能优化

### 1. 索引策略
```sql
-- 组合索引优化常用查询
CREATE INDEX CONCURRENTLY idx_license_assignment_member_status_active 
ON license_assignment (member_id, status, assigned_at DESC) 
WHERE status IN ('assigned', 'active') AND NOT is_deleted;

-- 过期查询优化
CREATE INDEX CONCURRENTLY idx_license_assignment_expires_status 
ON license_assignment (expires_at, status) 
WHERE expires_at IS NOT NULL AND NOT is_deleted;

-- 租户隔离查询优化
CREATE INDEX CONCURRENTLY idx_license_assignment_tenant_compound 
ON license_assignment (tenant_id, status, expires_at) 
WHERE NOT is_deleted;
```

### 2. 分页优化
```python
class OptimizedPagination:
    """优化的分页查询"""
    
    def paginate_assignments(self, queryset, page: int, page_size: int):
        """使用游标分页优化大数据集查询"""
        # 使用created_at作为游标字段
        offset = (page - 1) * page_size
        
        # 对于大偏移量，使用游标分页
        if offset > 10000:
            return self._cursor_paginate(queryset, page, page_size)
        else:
            return queryset[offset:offset + page_size]
    
    def _cursor_paginate(self, queryset, page: int, page_size: int):
        """游标分页实现"""
        # 获取游标位置
        cursor_offset = (page - 1) * page_size
        
        # 使用子查询获取游标值
        cursor_query = queryset.order_by('created_at').values_list(
            'created_at', flat=True
        )[cursor_offset:cursor_offset + 1]
        
        if cursor_query:
            cursor_value = cursor_query[0]
            return queryset.filter(created_at__gte=cursor_value).order_by(
                'created_at'
            )[:page_size]
        else:
            return queryset.none()
```

### 3. 批量操作优化
```python
class BatchOperationRepository:
    """批量操作仓储"""
    
    def bulk_create_assignments(self, assignments_data: List[dict]):
        """批量创建分配记录"""
        assignments = [
            LicenseAssignment(**data) for data in assignments_data
        ]
        
        # 使用bulk_create减少数据库交互
        created_assignments = LicenseAssignment.objects.bulk_create(
            assignments, 
            batch_size=1000,
            ignore_conflicts=False
        )
        
        return created_assignments
    
    def bulk_update_status(self, assignment_ids: List[int], new_status: str):
        """批量更新状态"""
        from django.utils import timezone
        
        # 构造更新字段
        update_fields = {'status': new_status}
        
        if new_status == 'revoked':
            update_fields['revoked_at'] = timezone.now()
        elif new_status == 'active':
            update_fields['activated_at'] = timezone.now()
        
        # 批量更新
        return LicenseAssignment.objects.filter(
            id__in=assignment_ids
        ).update(**update_fields)
```

---

**下一步**: 查看[API层设计](06_API层设计.md)了解REST API接口的具体设计
