# 业务流程详细设计

## 🎯 核心业务流程概览

### 业务流程分类
```
用户成长流程               权限管理流程              许可证集成流程
─────────────            ─────────────            ─────────────
• 积分获取流程            • 权限计算流程            • 配额检查流程
• 等级升级流程            • 标签管理流程            • 分配策略调整
• 降级保护流程            • 权限缓存管理            • 历史数据迁移
• 标签生命周期            • 跨租户权限控制          • 报表统计分析
```

## 🔄 积分获取与管理流程

### 1. 积分获取业务流程图

```
用户行为触发
    │
    ▼
┌─────────────────┐     ┌─────────────────┐
│  行为识别与验证  │     │   积分规则引擎   │
│                 │────▶│                 │
│ • 行为类型判断  │     │ • 规则匹配      │
│ • 频率限制检查  │     │ • 积分计算      │
│ • 有效性验证    │     │ • 奖励倍数      │
└─────────────────┘     └─────────┬───────┘
    │                             │
    ▼ [验证通过]                   ▼ [计算完成]
┌─────────────────┐     ┌─────────────────┐
│  积分发放处理   │     │   数据持久化    │
│                 │     │                 │
│ • 创建积分记录  │────▶│ • 更新用户积分  │
│ • 更新用户余额  │     │ • 记录操作日志  │
│ • 触发等级检查  │     │ • 缓存更新      │
└─────────────────┘     └─────────┬───────┘
    │                             │
    ▼                             ▼
┌─────────────────┐     ┌─────────────────┐
│  后续处理       │     │   通知推送      │
│                 │     │                 │
│ • 等级变更检查  │     │ • 积分到账通知  │
│ • 成就解锁      │     │ • 等级升级通知  │
│ • 统计更新      │     │ • 活动提醒      │
└─────────────────┘     └─────────────────┘
```

### 2. 具体积分获取规则实现

#### 每日登录积分
```
登录积分算法：
基础积分 = 10分
连续登录奖励 = min(连续天数 × 2, 50)  // 最高50分奖励
周末奖励 = 5分 (仅周六日)
新用户奖励 = 20分 (注册后7天内)

总积分 = 基础积分 + 连续登录奖励 + 周末奖励 + 新用户奖励

示例：
用户连续登录第5天（周日）且为新用户：
10 + (5×2) + 5 + 20 = 45分
```

#### 许可证相关积分
```
许可证积分规则：

申请许可证：
• 首次申请: +50分
• 后续申请: +30分
• 高级许可证: +额外20分

激活许可证：
• 首次激活: +80分  
• 7天内激活: +额外30分
• 企业许可证激活: +额外50分

使用活跃度：
• 每日使用: +5分
• 周活跃(使用5天以上): +50分
• 月活跃(使用20天以上): +200分

许可证续费：
• 自动续费: +金额×8分
• 手动续费: +金额×5分
• 提前续费(30天前): +额外100分
```

#### 社区贡献积分
```
社区活动积分规则：

内容贡献：
• 发布有用帖子: +50分 (质量评分≥4.0)
• 回答被采纳: +100分
• 获得点赞: +5分/个 (每日最多50分)
• 精华帖认定: +300分

Bug报告：
• 有效Bug: +200分
• 严重Bug: +500分
• 提供解决方案: +额外100分

产品改进：
• 功能建议被采纳: +300分
• 参与Beta测试: +150分/次
• 提交有效反馈: +50分
```

### 3. 积分消费流程设计

#### 积分消费业务流程

```
用户消费请求
    │
    ▼
┌─────────────────┐     ┌─────────────────┐
│  消费资格验证   │     │   积分充足检查   │
│                 │     │                 │
│ • 用户状态正常  │────▶│ • 可用积分计算  │
│ • 消费权限确认  │     │ • 消费数量验证  │
│ • 消费项目有效  │     │ • 预留积分检查  │
└─────────────────┘     └─────────┬───────┘
    │                             │
    ▼ [验证通过]                   ▼ [积分充足]
┌─────────────────┐     ┌─────────────────┐
│  积分扣除处理   │     │   消费执行      │
│                 │     │                 │
│ • 创建消费记录  │────▶│ • 提供消费服务  │
│ • 更新用户余额  │     │ • 更新服务状态  │
│ • 检查等级变化  │     │ • 记录使用日志  │
└─────────────────┘     └─────────┬───────┘
    │                             │
    ▼                             ▼
┌─────────────────┐     ┌─────────────────┐
│  后续处理       │     │   确认通知      │
│                 │     │                 │
│ • 等级重新计算  │     │ • 消费成功通知  │
│ • 权限更新      │     │ • 服务生效通知  │
│ • 统计数据更新  │     │ • 余额变动提醒  │
└─────────────────┘     └─────────────────┘
```

## ⬆️ 等级升级管理流程

### 1. 等级计算与升级流程

```
积分变动触发
    │
    ▼
┌─────────────────┐
│  等级重新计算   │
│                 │
│ current_points = user.total_points
│ 
│ FOR level IN levels ORDER BY level_order DESC:
│   IF current_points >= level.min_points AND
│      (level.max_points IS NULL OR 
│       current_points <= level.max_points):
│     new_level = level
│     BREAK
└─────────┬───────┘
          │
          ▼ [计算完成]
┌─────────────────┐     ┌─────────────────┐
│  等级变更检测   │ NO  │   无需处理      │
│                 ├────▶│                 │
│ IF new_level != │     │ • 保持现状      │
│    current_level│     │ • 记录检查日志  │
└─────────┬───────┘     └─────────────────┘
          │ YES
          ▼ [等级变化]
┌─────────────────┐
│  升级资格验证   │
│                 │
│ • 账户状态正常  │
│ • 无违规记录    │
│ • 满足前置条件  │
│ • 通过风险评估  │
└─────────┬───────┘
          │ [验证通过]
          ▼
┌─────────────────┐     ┌─────────────────┐
│  执行等级升级   │────▶│   升级奖励发放   │
│                 │     │                 │
│ • 更新用户等级  │     │ • 计算升级奖励  │
│ • 记录升级时间  │     │ • 发放奖励积分  │
│ • 清除权限缓存  │     │ • 解锁新功能    │
│ • 触发升级事件  │     │ • 发送升级礼品  │
└─────────────────┘     └─────────┬───────┘
          │                       │
          ▼                       ▼
┌─────────────────┐     ┌─────────────────┐
│  权限重新计算   │     │   升级通知      │
│                 │     │                 │
│ • 加载新等级权限│     │ • 升级成功通知  │
│ • 合并标签权限  │     │ • 新功能介绍    │
│ • 更新权限缓存  │     │ • 等级展示更新  │
│ • 同步到相关系统│     │ • 社交分享推荐  │
└─────────────────┘     └─────────────────┘
```

### 2. 降级保护机制

#### 降级保护决策流程

```
积分下降检测
    │
    ▼
┌─────────────────┐
│  降级风险评估   │
│                 │
│ current_points < current_level.min_points?
└─────────┬───────┘
          │ YES [存在降级风险]
          ▼
┌─────────────────┐     ┌─────────────────┐
│  保护策略判断   │     │   用户标签检查   │
│                 │────▶│                 │
│ • 用户类型      │     │ • VIP标签保护   │
│ • 付费状态      │     │ • 企业用户保护  │
│ • 历史贡献      │     │ • 特殊身份保护  │
└─────────────────┘     └─────────┬───────┘
          │                       │
          ▼                       ▼
┌─────────────────┐     ┌─────────────────┐
│  缓冲期机制     │     │   降级执行      │
│                 │     │                 │
│ • 30天保护期    │     │ • 更新到新等级  │
│ • 积分恢复提醒  │     │ • 调整权限配额  │
│ • 任务推荐      │     │ • 发送降级通知  │
│ • 专属支持      │     │ • 提供恢复建议  │
└─────────────────┘     └─────────────────┘
```

#### 具体保护规则

```
降级保护等级表：

用户类型          保护期    保护条件                   特殊政策
──────────       ──────   ─────────────────         ─────────────
普通用户         30天     积分不足当前等级要求        提供恢复任务
VIP用户          90天     VIP标签有效期内            保持VIP权限
企业用户         永久     企业认证有效期内            企业级保护
教育用户         180天    学期内                     教育优惠保护
开发者           60天     技术贡献记录良好            社区贡献保护

保护期内用户体验：
• 保持当前等级的所有权限
• 每周发送积分恢复提醒
• 提供专属的积分获取任务
• 优先客服支持和指导
• 社区导师配对支持
```

## 🔐 权限计算与管理流程

### 1. 用户权限实时计算流程

```
权限查询请求
    │
    ▼
┌─────────────────┐     ┌─────────────────┐
│  缓存检查       │ HIT │   返回缓存权限   │
│                 ├────▶│                 │
│ cache_key =     │     │ • 权限配置      │
│ "perms:{user_id}"│     │ • 配额信息      │
│ TTL: 30分钟     │     │ • 缓存时间戳    │
└─────────┬───────┘     └─────────────────┘
          │ MISS
          ▼
┌─────────────────┐     ┌─────────────────┐
│  基础数据加载   │────▶│   等级权限计算   │
│                 │     │                 │
│ • 用户积分      │     │ • 根据积分确定等级│
│ • 当前等级      │     │ • 加载等级基础权限│
│ • 活跃标签列表  │     │ • 计算基础配额    │
└─────────────────┘     └─────────┬───────┘
          │                       │
          ▼                       ▼
┌─────────────────┐     ┌─────────────────┐
│  标签权限叠加   │────▶│   最终权限合成   │
│                 │     │                 │
│ FOR tag IN tags:│     │ • 权限合并算法  │
│   perms += tag. │     │ • 配额倍数计算  │
│   permissions   │     │ • 特殊规则处理  │
│   quota *= tag. │     │ • 结果验证      │
│   multiplier    │     └─────────┬───────┘
└─────────────────┘               │
          │                       ▼
          ▼                ┌─────────────────┐
┌─────────────────┐       │   缓存更新      │
│  权限验证       │       │                 │
│                 │──────▶│ • 写入Redis缓存 │
│ • 权限有效性    │       │ • 设置过期时间  │
│ • 配额合理性    │       │ • 记录计算日志  │
│ • 业务规则检查  │       │ • 返回最终结果  │
└─────────────────┘       └─────────────────┘
```

### 2. 权限合并算法详解

#### 权限合并伪代码
```python
def merge_permissions(base_permissions, tag_permissions_list):
    """
    权限合并算法
    - 布尔类型权限：OR运算（任一为true则为true）
    - 数值类型权限：取最大值
    - 字符串类型权限：按优先级取值
    - 对象类型权限：递归合并
    """
    final_permissions = base_permissions.copy()
    
    for tag_perms in tag_permissions_list:
        for key, value in tag_perms.items():
            if key not in final_permissions:
                final_permissions[key] = value
            else:
                current_value = final_permissions[key]
                
                if isinstance(value, bool) and isinstance(current_value, bool):
                    # 布尔权限：OR运算
                    final_permissions[key] = current_value or value
                
                elif isinstance(value, (int, float)) and isinstance(current_value, (int, float)):
                    # 数值权限：取最大值
                    final_permissions[key] = max(current_value, value)
                
                elif isinstance(value, str) and isinstance(current_value, str):
                    # 字符串权限：按优先级
                    priority_map = {"basic": 1, "standard": 2, "premium": 3, "unlimited": 4}
                    if priority_map.get(value, 0) > priority_map.get(current_value, 0):
                        final_permissions[key] = value
                
                elif isinstance(value, dict) and isinstance(current_value, dict):
                    # 对象权限：递归合并
                    final_permissions[key] = merge_permissions(current_value, [value])
    
    return final_permissions

def calculate_quota_multiplier(tag_quota_modifiers_list):
    """配额倍数计算"""
    total_multiplier = 1.0
    
    for tag_quota in tag_quota_modifiers_list:
        multiplier = tag_quota.get('license_multiplier', 1.0)
        total_multiplier *= multiplier
    
    # 设置合理上限，避免无限制配额
    return min(total_multiplier, 10.0)
```

### 3. 标签生命周期管理

#### 标签授予流程
```
标签授予请求
    │
    ▼
┌─────────────────┐     ┌─────────────────┐
│  授予条件验证   │     │   用户资格检查   │
│                 │────▶│                 │
│ • 标签有效性    │     │ • 用户状态正常  │
│ • 授予权限      │     │ • 无冲突标签    │
│ • 业务规则      │     │ • 满足前置条件  │
└─────────────────┘     └─────────┬───────┘
          │                       │
          ▼ [验证通过]              ▼ [资格确认]
┌─────────────────┐     ┌─────────────────┐
│  标签记录创建   │────▶│   权限生效处理   │
│                 │     │                 │
│ • 创建关联记录  │     │ • 清除权限缓存  │
│ • 设置有效期    │     │ • 重新计算权限  │
│ • 记录授予信息  │     │ • 同步到业务系统│
└─────────────────┘     └─────────┬───────┘
          │                       │
          ▼                       ▼
┌─────────────────┐     ┌─────────────────┐
│  后续处理       │     │   授予通知      │
│                 │     │                 │
│ • 积分奖励      │     │ • 标签获得通知  │
│ • 成就解锁      │     │ • 功能介绍指南  │
│ • 统计更新      │     │ • 专属权益说明  │
└─────────────────┘     └─────────────────┘
```

#### 标签过期处理
```
定时任务：每小时检查标签过期

检查过期标签
    │
    ▼
┌─────────────────┐     ┌─────────────────┐
│  过期标签识别   │────▶│   过期前提醒     │
│                 │     │                 │
│ SELECT * FROM   │     │ • 7天前提醒     │
│ member_type_tag │     │ • 1天前提醒     │
│ WHERE expires_at│     │ • 即将过期提醒  │
│ BETWEEN NOW()   │     │ • 续费引导      │
│ AND NOW()+7DAYS │     └─────────────────┘
└─────────────────┘
          │
          ▼ [标签已过期]
┌─────────────────┐     ┌─────────────────┐
│  标签失效处理   │────▶│   权限调整      │
│                 │     │                 │
│ • 更新状态expired│     │ • 清除权限缓存  │
│ • 记录过期时间  │     │ • 重新计算权限  │
│ • 保留历史记录  │     │ • 降级保护检查  │
└─────────────────┘     └─────────┬───────┘
          │                       │
          ▼                       ▼
┌─────────────────┐     ┌─────────────────┐
│  过期通知       │     │   挽回策略      │
│                 │     │                 │
│ • 过期提醒通知  │     │ • 续费优惠推送  │
│ • 权限变更说明  │     │ • 恢复方案建议  │
│ • 影响功能列表  │     │ • 客服主动联系  │
└─────────────────┘     └─────────────────┘
```

## 🔗 许可证系统集成流程

### 1. 许可证申请集成新流程

```
用户申请许可证
    │
    ▼
┌─────────────────┐     ┌─────────────────┐
│  用户权限查询   │────▶│   用户等级权限   │
│                 │     │                 │
│ user_permissions│     │ • 基础等级配额  │
│ = calculate_    │     │ • 标签权限加成  │
│ permissions(    │     │ • 特殊权限处理  │
│ user_id)        │     │ • 最终配额计算  │
└─────────────────┘     └─────────┬───────┘
          │                       │
          ▼                       ▼
┌─────────────────┐     ┌─────────────────┐
│  多层配额检查   │     │   用户配额检查   │
│                 │     │                 │
│ 1. 用户等级配额 │────▶│ current_licenses│
│ 2. License配额  │     │ <= user_quota.  │
│ 3. 租户总配额   │     │ max_licenses?   │
│ 4. 产品特殊配额 │     └─────────┬───────┘
└─────────────────┘               │ [配额充足]
          │                       ▼
          ▼ [所有检查通过]  ┌─────────────────┐
┌─────────────────┐       │   分配执行      │
│  创建分配记录   │──────▶│                 │
│                 │       │ • 创建assignment│
│ • LicenseAssign-│       │ • 更新License计数│
│   ment记录      │       │ • 积分奖励发放  │
│ • 积分奖励计算  │       │ • 成就检查      │
│ • 统计数据更新  │       │ • 通知推送      │
└─────────────────┘       └─────────────────┘
```

### 2. 配额检查详细算法

```python
def check_license_quota(user_id, license_id, request_count=1):
    """
    多层配额检查算法
    """
    # 1. 获取用户权限配置
    user_perms = calculate_user_permissions(user_id)
    user_quota = user_perms['quota']
    
    # 2. 检查用户等级配额
    current_user_licenses = count_user_licenses(user_id, status=['assigned', 'active'])
    max_user_licenses = user_quota.get('max_licenses', 0)
    
    if current_user_licenses + request_count > max_user_licenses:
        return {
            'allowed': False,
            'reason': 'USER_QUOTA_EXCEEDED',
            'details': {
                'current': current_user_licenses,
                'max': max_user_licenses,
                'requested': request_count
            }
        }
    
    # 3. 检查License配额
    license_info = get_license_info(license_id)
    if license_info.current_activations + request_count > license_info.max_activations:
        return {
            'allowed': False,
            'reason': 'LICENSE_QUOTA_EXCEEDED',
            'details': {
                'current': license_info.current_activations,
                'max': license_info.max_activations,
                'requested': request_count
            }
        }
    
    # 4. 检查租户配额
    tenant_quota = get_tenant_quota(user_id)
    current_tenant_licenses = count_tenant_licenses(get_user_tenant(user_id))
    
    if current_tenant_licenses + request_count > tenant_quota.max_licenses:
        return {
            'allowed': False,
            'reason': 'TENANT_QUOTA_EXCEEDED',
            'details': {
                'current': current_tenant_licenses,
                'max': tenant_quota.max_licenses,
                'requested': request_count
            }
        }
    
    # 5. 检查产品特殊限制
    product_limits = get_product_limits(license_info.product_id, user_perms['level'])
    if not check_product_access(user_perms, product_limits):
        return {
            'allowed': False,
            'reason': 'PRODUCT_ACCESS_DENIED',
            'details': {
                'required_level': product_limits.min_level,
                'user_level': user_perms['level']
            }
        }
    
    return {
        'allowed': True,
        'quota_info': {
            'user_quota': {'current': current_user_licenses, 'max': max_user_licenses},
            'license_quota': {'current': license_info.current_activations, 'max': license_info.max_activations},
            'tenant_quota': {'current': current_tenant_licenses, 'max': tenant_quota.max_licenses}
        }
    }
```

## 📊 数据同步与一致性保障

### 1. 积分数据一致性保障

```
积分更新事务流程：

BEGIN TRANSACTION;

1. 检查用户账户状态
   IF user.is_deleted OR user.status != 'active':
     ROLLBACK; RETURN error;

2. 验证积分操作合法性
   IF point_change < 0 AND user.available_points < ABS(point_change):
     ROLLBACK; RETURN insufficient_points;

3. 创建积分记录
   INSERT INTO user_points (member_id, points, balance_before, balance_after, ...);

4. 更新用户积分余额
   UPDATE member SET 
     total_points = total_points + point_change,
     available_points = calculate_available_points(member_id),
     last_points_update = NOW()
   WHERE id = member_id;

5. 检查等级变化
   new_level = calculate_user_level(total_points);
   IF new_level != current_level:
     UPDATE member SET current_level_id = new_level.id, level_updated_at = NOW();
     INSERT INTO level_change_log (...);

6. 清除相关缓存
   DELETE FROM cache WHERE key IN ('perms:' || member_id, 'level:' || member_id);

COMMIT;

-- 异步后续处理
NOTIFY 'points_changed', json_build_object('member_id', member_id, 'points', point_change);
```

### 2. 权限缓存同步策略

```
缓存更新策略：

1. 写时失效 (Write-Through)
   用户等级/标签变更时 → 立即清除权限缓存 → 下次访问时重新计算

2. 定时刷新 (Time-Based)
   每30分钟自动过期 → 防止长期缓存不一致

3. 事件驱动更新 (Event-Driven)
   等级升级事件 → 权限缓存更新
   标签变更事件 → 权限缓存更新
   系统配置变更 → 批量清除缓存

4. 一致性检查 (Consistency Check)
   每日凌晨 → 批量验证缓存一致性
   发现不一致 → 自动修复 + 告警通知
```

---

**下一步**: 查看[技术实现指南](17_技术实现指南.md)了解具体的代码实现方案
