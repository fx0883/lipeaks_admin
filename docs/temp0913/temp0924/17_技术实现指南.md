# æŠ€æœ¯å®ç°æŒ‡å—

## ğŸ¯ æŠ€æœ¯æ¶æ„æ¦‚è§ˆ

### ç³»ç»ŸæŠ€æœ¯æ ˆ
```
åç«¯æ¡†æ¶:        Django 4.2 + Django REST Framework
æ•°æ®åº“:          PostgreSQL 15 (ä¸»åº“) + Redis 7 (ç¼“å­˜)
æ¶ˆæ¯é˜Ÿåˆ—:        Celery + Redis (å¼‚æ­¥ä»»åŠ¡)
ç¼“å­˜ç­–ç•¥:        Redis (æƒé™ç¼“å­˜) + DBç¼“å­˜ (æŸ¥è¯¢ç¼“å­˜)
ç›‘æ§æ—¥å¿—:        Django Logging + è‡ªå®šä¹‰æ—¥å¿—è®°å½•
APIæ–‡æ¡£:         drf-spectacular (OpenAPI 3.0)
```

### æ ¸å¿ƒæ¨¡å—ç»“æ„
```
user_level_system/
â”œâ”€â”€ models/              # æ•°æ®æ¨¡å‹
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ user_level.py    # ç”¨æˆ·ç­‰çº§æ¨¡å‹
â”‚   â”œâ”€â”€ user_points.py   # ç§¯åˆ†è®°å½•æ¨¡å‹
â”‚   â”œâ”€â”€ user_tags.py     # ç”¨æˆ·æ ‡ç­¾æ¨¡å‹
â”‚   â””â”€â”€ managers.py      # è‡ªå®šä¹‰Manager
â”œâ”€â”€ services/            # ä¸šåŠ¡æœåŠ¡å±‚
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ points_service.py    # ç§¯åˆ†ç®¡ç†æœåŠ¡
â”‚   â”œâ”€â”€ level_service.py     # ç­‰çº§ç®¡ç†æœåŠ¡
â”‚   â”œâ”€â”€ permission_service.py # æƒé™è®¡ç®—æœåŠ¡
â”‚   â””â”€â”€ tag_service.py       # æ ‡ç­¾ç®¡ç†æœåŠ¡
â”œâ”€â”€ tasks/               # å¼‚æ­¥ä»»åŠ¡
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ points_tasks.py      # ç§¯åˆ†ç›¸å…³ä»»åŠ¡
â”‚   â””â”€â”€ level_tasks.py       # ç­‰çº§ç›¸å…³ä»»åŠ¡
â”œâ”€â”€ api/                 # APIæ¥å£
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ views.py
â”‚   â”œâ”€â”€ serializers.py
â”‚   â””â”€â”€ permissions.py
â”œâ”€â”€ utils/               # å·¥å…·ç±»
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ cache.py         # ç¼“å­˜å·¥å…·
â”‚   â”œâ”€â”€ events.py        # äº‹ä»¶å¤„ç†
â”‚   â””â”€â”€ constants.py     # å¸¸é‡å®šä¹‰
â””â”€â”€ tests/              # æµ‹è¯•ä»£ç 
    â”œâ”€â”€ test_models.py
    â”œâ”€â”€ test_services.py
    â””â”€â”€ test_api.py
```

## ğŸ—„ï¸ æ ¸å¿ƒæ¨¡å‹å®ç°

### 1. UserLevelæ¨¡å‹
```python
# models/user_level.py
from django.db import models
from django.contrib.postgres.fields import JSONField
from django.core.validators import MinValueValidator

class UserLevel(models.Model):
    """ç”¨æˆ·ç­‰çº§æ¨¡å‹"""
    
    level_name = models.CharField('ç­‰çº§åç§°', max_length=50)
    level_code = models.CharField('ç­‰çº§ä»£ç ', max_length=20, unique=True)
    level_order = models.PositiveIntegerField('ç­‰çº§é¡ºåº', unique=True)
    
    min_points = models.PositiveIntegerField('æœ€å°ç§¯åˆ†', validators=[MinValueValidator(0)])
    max_points = models.PositiveIntegerField('æœ€å¤§ç§¯åˆ†', null=True, blank=True)
    
    base_permissions = models.JSONField('åŸºç¡€æƒé™', default=dict)
    base_quota_config = models.JSONField('åŸºç¡€é…é¢', default=dict)
    level_benefits = models.JSONField('ç­‰çº§ç¦åˆ©', default=dict)
    
    level_icon = models.URLField('ç­‰çº§å›¾æ ‡', blank=True)
    level_color = models.CharField('ç­‰çº§é¢œè‰²', max_length=7, blank=True)
    level_description = models.TextField('ç­‰çº§æè¿°', blank=True)
    
    is_active = models.BooleanField('æ˜¯å¦å¯ç”¨', default=True)
    created_at = models.DateTimeField('åˆ›å»ºæ—¶é—´', auto_now_add=True)
    updated_at = models.DateTimeField('æ›´æ–°æ—¶é—´', auto_now=True)
    
    class Meta:
        db_table = 'user_level'
        verbose_name = 'ç”¨æˆ·ç­‰çº§'
        verbose_name_plural = 'ç”¨æˆ·ç­‰çº§'
        ordering = ['level_order']
    
    def __str__(self):
        return f"{self.level_name} (Level {self.level_order})"
    
    @classmethod
    def get_level_by_points(cls, points):
        """æ ¹æ®ç§¯åˆ†è·å–å¯¹åº”ç­‰çº§"""
        return cls.objects.filter(
            min_points__lte=points,
            is_active=True
        ).filter(
            models.Q(max_points__isnull=True) | models.Q(max_points__gte=points)
        ).order_by('-level_order').first()
    
    def clean(self):
        """æ¨¡å‹éªŒè¯"""
        super().clean()
        if self.max_points and self.max_points < self.min_points:
            raise models.ValidationError('æœ€å¤§ç§¯åˆ†ä¸èƒ½å°äºæœ€å°ç§¯åˆ†')
```

### 2. UserPointsæ¨¡å‹
```python
# models/user_points.py
from django.db import models, transaction
from django.utils import timezone
from django.core.exceptions import ValidationError

class UserPointsManager(models.Manager):
    """ç§¯åˆ†è®°å½•ç®¡ç†å™¨"""
    
    def add_points(self, member, points, category, subcategory=None, 
                   source_type=None, source_id=None, description=None, 
                   expires_days=None):
        """æ·»åŠ ç§¯åˆ†"""
        if points <= 0:
            raise ValueError("ç§¯åˆ†æ•°é‡å¿…é¡»å¤§äº0")
        
        with transaction.atomic():
            # è®¡ç®—è¿‡æœŸæ—¶é—´
            expires_at = None
            if expires_days:
                expires_at = timezone.now() + timezone.timedelta(days=expires_days)
            
            # è·å–å½“å‰ä½™é¢
            current_balance = member.total_points
            
            # åˆ›å»ºç§¯åˆ†è®°å½•
            point_record = self.create(
                member=member,
                point_type='earn',
                category=category,
                subcategory=subcategory,
                points=points,
                balance_before=current_balance,
                balance_after=current_balance + points,
                source_type=source_type,
                source_id=source_id,
                operation_reason=description,
                expires_at=expires_at
            )
            
            # æ›´æ–°ç”¨æˆ·ç§¯åˆ†
            member.total_points = models.F('total_points') + points
            member.last_points_update = timezone.now()
            member.save(update_fields=['total_points', 'last_points_update'])
            
            # åˆ·æ–°æ•°æ®
            member.refresh_from_db()
            
            return point_record
    
    def spend_points(self, member, points, category, subcategory=None, 
                     description=None):
        """æ¶ˆè´¹ç§¯åˆ†"""
        if points <= 0:
            raise ValueError("æ¶ˆè´¹ç§¯åˆ†æ•°é‡å¿…é¡»å¤§äº0")
        
        if member.available_points < points:
            raise ValidationError("å¯ç”¨ç§¯åˆ†ä¸è¶³")
        
        with transaction.atomic():
            current_balance = member.total_points
            
            point_record = self.create(
                member=member,
                point_type='spend',
                category=category,
                subcategory=subcategory,
                points=-points,  # æ¶ˆè´¹ä¸ºè´Ÿæ•°
                balance_before=current_balance,
                balance_after=current_balance - points,
                operation_reason=description
            )
            
            # æ›´æ–°ç”¨æˆ·ç§¯åˆ†
            member.total_points = models.F('total_points') - points
            member.available_points = models.F('available_points') - points
            member.last_points_update = timezone.now()
            member.save(update_fields=['total_points', 'available_points', 'last_points_update'])
            
            member.refresh_from_db()
            return point_record

class UserPoints(models.Model):
    """ç”¨æˆ·ç§¯åˆ†è®°å½•"""
    
    POINT_TYPES = [
        ('earn', 'è·å¾—'),
        ('spend', 'æ¶ˆè´¹'),
        ('expire', 'è¿‡æœŸ'),
        ('adjust', 'è°ƒæ•´'),
    ]
    
    STATUS_CHOICES = [
        ('active', 'æœ‰æ•ˆ'),
        ('expired', 'å·²è¿‡æœŸ'),
        ('cancelled', 'å·²å–æ¶ˆ'),
        ('adjusted', 'å·²è°ƒæ•´'),
    ]
    
    member = models.ForeignKey('users.Member', on_delete=models.CASCADE, related_name='point_records')
    
    point_type = models.CharField('ç§¯åˆ†ç±»å‹', max_length=10, choices=POINT_TYPES)
    category = models.CharField('ä¸šåŠ¡åˆ†ç±»', max_length=50)
    subcategory = models.CharField('å­åˆ†ç±»', max_length=50, blank=True)
    
    points = models.IntegerField('ç§¯åˆ†æ•°é‡')
    balance_before = models.PositiveIntegerField('æ“ä½œå‰ä½™é¢')
    balance_after = models.PositiveIntegerField('æ“ä½œåä½™é¢')
    
    source_type = models.CharField('æ¥æºç±»å‹', max_length=50, blank=True)
    source_id = models.PositiveIntegerField('æ¥æºID', null=True, blank=True)
    source_description = models.TextField('æ¥æºæè¿°', blank=True)
    
    earned_at = models.DateTimeField('è·å¾—æ—¶é—´', default=timezone.now)
    expires_at = models.DateTimeField('è¿‡æœŸæ—¶é—´', null=True, blank=True)
    expired_at = models.DateTimeField('å®é™…è¿‡æœŸæ—¶é—´', null=True, blank=True)
    
    operation_reason = models.TextField('æ“ä½œåŸå› ', blank=True)
    operator = models.ForeignKey('users.User', on_delete=models.SET_NULL, null=True, blank=True)
    batch_id = models.CharField('æ‰¹æ¬¡ID', max_length=100, blank=True)
    
    status = models.CharField('çŠ¶æ€', max_length=20, choices=STATUS_CHOICES, default='active')
    is_manual = models.BooleanField('æ˜¯å¦æ‰‹åŠ¨æ“ä½œ', default=False)
    
    created_at = models.DateTimeField('åˆ›å»ºæ—¶é—´', auto_now_add=True)
    
    objects = UserPointsManager()
    
    class Meta:
        db_table = 'user_points'
        verbose_name = 'ç”¨æˆ·ç§¯åˆ†è®°å½•'
        verbose_name_plural = 'ç”¨æˆ·ç§¯åˆ†è®°å½•'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['member', '-created_at']),
            models.Index(fields=['point_type', 'category']),
            models.Index(fields=['expires_at'], condition=models.Q(expires_at__isnull=False)),
        ]
    
    def clean(self):
        if self.points == 0:
            raise ValidationError('ç§¯åˆ†æ•°é‡ä¸èƒ½ä¸º0')
        if self.balance_after != self.balance_before + self.points:
            raise ValidationError('ç§¯åˆ†ä½™é¢è®¡ç®—é”™è¯¯')
```

## âš™ï¸ æ ¸å¿ƒæœåŠ¡å®ç°

### 1. æƒé™è®¡ç®—æœåŠ¡
```python
# services/permission_service.py
import json
import logging
from typing import Dict, List, Any
from django.core.cache import cache
from django.conf import settings
from .level_service import LevelService
from .tag_service import TagService

logger = logging.getLogger(__name__)

class PermissionService:
    """æƒé™è®¡ç®—æœåŠ¡"""
    
    CACHE_PREFIX = 'user_perms'
    CACHE_TIMEOUT = 30 * 60  # 30åˆ†é’Ÿ
    
    def __init__(self):
        self.level_service = LevelService()
        self.tag_service = TagService()
    
    def get_user_permissions(self, member_id: int, force_refresh: bool = False) -> Dict[str, Any]:
        """è·å–ç”¨æˆ·å®Œæ•´æƒé™é…ç½®"""
        cache_key = f"{self.CACHE_PREFIX}:{member_id}"
        
        if not force_refresh:
            cached_perms = cache.get(cache_key)
            if cached_perms:
                logger.debug(f"ä»ç¼“å­˜è·å–ç”¨æˆ· {member_id} æƒé™")
                return cached_perms
        
        # è®¡ç®—ç”¨æˆ·æƒé™
        permissions = self._calculate_user_permissions(member_id)
        
        # ç¼“å­˜ç»“æœ
        cache.set(cache_key, permissions, self.CACHE_TIMEOUT)
        logger.info(f"è®¡ç®—å¹¶ç¼“å­˜ç”¨æˆ· {member_id} æƒé™")
        
        return permissions
    
    def _calculate_user_permissions(self, member_id: int) -> Dict[str, Any]:
        """è®¡ç®—ç”¨æˆ·æƒé™"""
        try:
            from users.models import Member
            member = Member.objects.select_related('current_level').get(id=member_id)
        except Member.DoesNotExist:
            logger.error(f"ç”¨æˆ· {member_id} ä¸å­˜åœ¨")
            return self._get_default_permissions()
        
        # 1. è·å–åŸºç¡€ç­‰çº§æƒé™
        level_permissions, level_quota = self._get_level_permissions(member)
        
        # 2. è·å–ç”¨æˆ·æ ‡ç­¾æƒé™
        tag_permissions_list, tag_quota_modifiers = self._get_tag_permissions(member)
        
        # 3. åˆå¹¶æƒé™
        final_permissions = self._merge_permissions(level_permissions, tag_permissions_list)
        
        # 4. è®¡ç®—æœ€ç»ˆé…é¢
        final_quota = self._calculate_final_quota(level_quota, tag_quota_modifiers)
        
        return {
            'member_id': member_id,
            'level': {
                'id': member.current_level.id if member.current_level else None,
                'name': member.current_level.level_name if member.current_level else 'æœªè®¾ç½®',
                'code': member.current_level.level_code if member.current_level else 'none',
                'order': member.current_level.level_order if member.current_level else 0,
            },
            'total_points': member.total_points,
            'available_points': member.available_points,
            'permissions': final_permissions,
            'quota': final_quota,
            'tags': self._get_user_tag_info(member),
            'calculated_at': timezone.now().isoformat(),
        }
    
    def _get_level_permissions(self, member) -> tuple:
        """è·å–ç­‰çº§æƒé™"""
        if not member.current_level:
            # å¦‚æœç”¨æˆ·æ²¡æœ‰ç­‰çº§ï¼Œæ ¹æ®ç§¯åˆ†è®¡ç®—
            from models.user_level import UserLevel
            level = UserLevel.get_level_by_points(member.total_points)
            if level:
                # æ›´æ–°ç”¨æˆ·ç­‰çº§
                member.current_level = level
                member.level_updated_at = timezone.now()
                member.save(update_fields=['current_level', 'level_updated_at'])
        
        if member.current_level:
            return member.current_level.base_permissions, member.current_level.base_quota_config
        else:
            return {}, {}
    
    def _get_tag_permissions(self, member) -> tuple:
        """è·å–æ ‡ç­¾æƒé™"""
        active_tags = self.tag_service.get_user_active_tags(member.id)
        
        tag_permissions = []
        tag_quota_modifiers = []
        
        for tag_relation in active_tags:
            tag = tag_relation.tag
            tag_permissions.append(tag.permission_modifiers or {})
            tag_quota_modifiers.append(tag.quota_modifiers or {})
        
        return tag_permissions, tag_quota_modifiers
    
    def _merge_permissions(self, base_permissions: Dict, tag_permissions_list: List[Dict]) -> Dict:
        """åˆå¹¶æƒé™"""
        final_permissions = base_permissions.copy()
        
        for tag_perms in tag_permissions_list:
            final_permissions = self._merge_two_permissions(final_permissions, tag_perms)
        
        return final_permissions
    
    def _merge_two_permissions(self, perm1: Dict, perm2: Dict) -> Dict:
        """åˆå¹¶ä¸¤ä¸ªæƒé™é…ç½®"""
        result = perm1.copy()
        
        for key, value in perm2.items():
            if key not in result:
                result[key] = value
            else:
                current_value = result[key]
                
                if isinstance(value, bool) and isinstance(current_value, bool):
                    # å¸ƒå°”æƒé™ï¼šORè¿ç®—
                    result[key] = current_value or value
                elif isinstance(value, (int, float)) and isinstance(current_value, (int, float)):
                    # æ•°å€¼æƒé™ï¼šå–æœ€å¤§å€¼
                    result[key] = max(current_value, value)
                elif isinstance(value, str) and isinstance(current_value, str):
                    # å­—ç¬¦ä¸²æƒé™ï¼šæŒ‰ä¼˜å…ˆçº§
                    priority_map = {
                        "basic": 1, "standard": 2, "advanced": 3, 
                        "premium": 4, "unlimited": 5
                    }
                    if priority_map.get(value, 0) > priority_map.get(current_value, 0):
                        result[key] = value
                elif isinstance(value, dict) and isinstance(current_value, dict):
                    # å­—å…¸æƒé™ï¼šé€’å½’åˆå¹¶
                    result[key] = self._merge_two_permissions(current_value, value)
        
        return result
    
    def _calculate_final_quota(self, base_quota: Dict, tag_quota_modifiers: List[Dict]) -> Dict:
        """è®¡ç®—æœ€ç»ˆé…é¢"""
        final_quota = base_quota.copy()
        
        # è®¡ç®—ä¹˜æ•°
        license_multiplier = 1.0
        device_multiplier = 1.0
        
        for modifier in tag_quota_modifiers:
            license_multiplier *= modifier.get('license_multiplier', 1.0)
            device_multiplier *= modifier.get('device_multiplier', 1.0)
        
        # åº”ç”¨ä¹˜æ•°ï¼ˆè®¾ç½®åˆç†ä¸Šé™ï¼‰
        if 'max_licenses' in final_quota:
            final_quota['max_licenses'] = min(
                int(final_quota['max_licenses'] * license_multiplier),
                1000  # æœ€å¤§1000ä¸ªè®¸å¯è¯
            )
        
        if 'max_devices_per_license' in final_quota:
            final_quota['max_devices_per_license'] = min(
                int(final_quota['max_devices_per_license'] * device_multiplier),
                50  # æœ€å¤§50ä¸ªè®¾å¤‡
            )
        
        # å¤„ç†ç‰¹æ®Šæ ‡ç­¾æƒé™
        for modifier in tag_quota_modifiers:
            if modifier.get('unlimited_licenses'):
                final_quota['max_licenses'] = -1  # -1è¡¨ç¤ºæ— é™åˆ¶
            if modifier.get('unlimited_devices'):
                final_quota['max_devices_per_license'] = -1
        
        return final_quota
    
    def check_permission(self, member_id: int, permission_key: str) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ‹¥æœ‰ç‰¹å®šæƒé™"""
        permissions = self.get_user_permissions(member_id)
        return self._get_nested_permission(permissions['permissions'], permission_key)
    
    def _get_nested_permission(self, permissions: Dict, key: str) -> bool:
        """è·å–åµŒå¥—æƒé™å€¼"""
        keys = key.split('.')
        current = permissions
        
        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return False
        
        return bool(current) if not isinstance(current, dict) else False
    
    def invalidate_user_permissions_cache(self, member_id: int):
        """å¤±æ•ˆç”¨æˆ·æƒé™ç¼“å­˜"""
        cache_key = f"{self.CACHE_PREFIX}:{member_id}"
        cache.delete(cache_key)
        logger.info(f"æ¸…é™¤ç”¨æˆ· {member_id} æƒé™ç¼“å­˜")
    
    def _get_default_permissions(self) -> Dict[str, Any]:
        """è·å–é»˜è®¤æƒé™é…ç½®"""
        return {
            'member_id': None,
            'level': {'id': None, 'name': 'æœªè®¾ç½®', 'code': 'none', 'order': 0},
            'total_points': 0,
            'available_points': 0,
            'permissions': {'license_request': False},
            'quota': {'max_licenses': 0, 'max_devices_per_license': 0},
            'tags': [],
            'calculated_at': timezone.now().isoformat(),
        }
```

### 2. ç§¯åˆ†ç®¡ç†æœåŠ¡
```python
# services/points_service.py
import logging
from datetime import timedelta
from django.utils import timezone
from django.db import transaction
from django.core.exceptions import ValidationError
from .permission_service import PermissionService

logger = logging.getLogger(__name__)

class PointsService:
    """ç§¯åˆ†ç®¡ç†æœåŠ¡"""
    
    # ç§¯åˆ†è·å–è§„åˆ™é…ç½®
    POINTS_RULES = {
        'daily_login': {
            'base_points': 10,
            'max_consecutive_bonus': 50,
            'weekend_bonus': 5,
            'new_user_bonus': 20,  # æ³¨å†Œå7å¤©å†…
        },
        'license_activity': {
            'first_apply': 50,
            'apply': 30,
            'first_activate': 80,
            'activate_in_week': 30,
            'daily_usage': 5,
            'weekly_active': 50,  # ä½¿ç”¨5å¤©+
            'monthly_active': 200,  # ä½¿ç”¨20å¤©+
        },
        'social_activity': {
            'useful_post': 50,  # è´¨é‡è¯„åˆ†â‰¥4.0
            'answer_accepted': 100,
            'get_like': 5,  # æ¯æ—¥æœ€å¤š50åˆ†
            'featured_post': 300,
            'valid_bug_report': 200,
            'critical_bug_report': 500,
            'feature_suggestion_accepted': 300,
            'beta_test_participation': 150,
        },
        'payment_activity': {
            'vip_purchase_multiplier': 10,  # ä»˜è´¹é‡‘é¢Ã—10
            'enterprise_certification': 500,
            'referral_enterprise': 1000,
            'annual_renewal_multiplier': 15,  # å¹´è´¹Ã—15
        }
    }
    
    def __init__(self):
        self.permission_service = PermissionService()
    
    def add_daily_login_points(self, member_id: int) -> Dict[str, Any]:
        """æ·»åŠ æ¯æ—¥ç™»å½•ç§¯åˆ†"""
        from users.models import Member
        
        try:
            member = Member.objects.get(id=member_id)
        except Member.DoesNotExist:
            raise ValidationError(f"ç”¨æˆ· {member_id} ä¸å­˜åœ¨")
        
        # æ£€æŸ¥ä»Šæ—¥æ˜¯å¦å·²ç»è·å¾—ç™»å½•ç§¯åˆ†
        today = timezone.now().date()
        today_login_points = member.point_records.filter(
            category='daily_login',
            earned_at__date=today
        ).exists()
        
        if today_login_points:
            return {'success': False, 'reason': 'ä»Šæ—¥å·²è·å¾—ç™»å½•ç§¯åˆ†'}
        
        # è®¡ç®—ç§¯åˆ†
        points = self._calculate_daily_login_points(member)
        
        # æ·»åŠ ç§¯åˆ†
        with transaction.atomic():
            point_record = UserPoints.objects.add_points(
                member=member,
                points=points,
                category='daily_login',
                subcategory='daily_checkin',
                description=f"æ¯æ—¥ç™»å½•å¥–åŠ± (+{points}åˆ†)",
                expires_days=365  # 1å¹´è¿‡æœŸ
            )
            
            # æ£€æŸ¥ç­‰çº§å˜åŒ–
            self._check_and_update_level(member)
            
            # å¤±æ•ˆæƒé™ç¼“å­˜
            self.permission_service.invalidate_user_permissions_cache(member_id)
        
        logger.info(f"ç”¨æˆ· {member_id} è·å¾—æ¯æ—¥ç™»å½•ç§¯åˆ† {points}")
        
        return {
            'success': True,
            'points_earned': points,
            'total_points': member.total_points,
            'point_record_id': point_record.id,
        }
    
    def _calculate_daily_login_points(self, member) -> int:
        """è®¡ç®—æ¯æ—¥ç™»å½•ç§¯åˆ†"""
        rules = self.POINTS_RULES['daily_login']
        points = rules['base_points']
        
        # è¿ç»­ç™»å½•å¥–åŠ±
        consecutive_days = self._get_consecutive_login_days(member)
        consecutive_bonus = min(consecutive_days * 2, rules['max_consecutive_bonus'])
        points += consecutive_bonus
        
        # å‘¨æœ«å¥–åŠ±
        if timezone.now().weekday() in [5, 6]:  # å‘¨å…­æ—¥
            points += rules['weekend_bonus']
        
        # æ–°ç”¨æˆ·å¥–åŠ±
        if (timezone.now().date() - member.created_at.date()).days < 7:
            points += rules['new_user_bonus']
        
        return points
    
    def add_license_activity_points(self, member_id: int, activity_type: str, 
                                   license_id: int = None, **kwargs) -> Dict[str, Any]:
        """æ·»åŠ è®¸å¯è¯ç›¸å…³æ´»åŠ¨ç§¯åˆ†"""
        from users.models import Member
        
        member = Member.objects.get(id=member_id)
        rules = self.POINTS_RULES['license_activity']
        
        points = 0
        subcategory = activity_type
        description = ""
        
        if activity_type == 'apply':
            # æ£€æŸ¥æ˜¯å¦é¦–æ¬¡ç”³è¯·
            is_first_apply = not member.point_records.filter(
                category='license_activity',
                subcategory__in=['first_apply', 'apply']
            ).exists()
            
            if is_first_apply:
                points = rules['first_apply']
                subcategory = 'first_apply'
                description = f"é¦–æ¬¡ç”³è¯·è®¸å¯è¯å¥–åŠ± (+{points}åˆ†)"
            else:
                points = rules['apply']
                description = f"ç”³è¯·è®¸å¯è¯å¥–åŠ± (+{points}åˆ†)"
        
        elif activity_type == 'activate':
            # æ£€æŸ¥æ˜¯å¦é¦–æ¬¡æ¿€æ´»
            is_first_activate = not member.point_records.filter(
                category='license_activity',
                subcategory__in=['first_activate', 'activate']
            ).exists()
            
            if is_first_activate:
                points = rules['first_activate']
                subcategory = 'first_activate'
                description = f"é¦–æ¬¡æ¿€æ´»è®¸å¯è¯å¥–åŠ± (+{points}åˆ†)"
            else:
                # æ£€æŸ¥æ˜¯å¦åœ¨7å¤©å†…æ¿€æ´»
                apply_time = kwargs.get('apply_time')
                if apply_time and (timezone.now() - apply_time).days <= 7:
                    points = rules['activate_in_week']
                    description = f"7å¤©å†…æ¿€æ´»è®¸å¯è¯å¥–åŠ± (+{points}åˆ†)"
                else:
                    points = 30  # åŸºç¡€æ¿€æ´»å¥–åŠ±
                    description = f"æ¿€æ´»è®¸å¯è¯å¥–åŠ± (+{points}åˆ†)"
        
        elif activity_type == 'daily_usage':
            # æ£€æŸ¥ä»Šæ—¥æ˜¯å¦å·²è·å¾—ä½¿ç”¨ç§¯åˆ†
            today = timezone.now().date()
            today_usage_points = member.point_records.filter(
                category='license_activity',
                subcategory='daily_usage',
                earned_at__date=today,
                source_id=license_id
            ).exists()
            
            if today_usage_points:
                return {'success': False, 'reason': 'ä»Šæ—¥è¯¥è®¸å¯è¯å·²è·å¾—ä½¿ç”¨ç§¯åˆ†'}
            
            points = rules['daily_usage']
            description = f"æ¯æ—¥ä½¿ç”¨è®¸å¯è¯å¥–åŠ± (+{points}åˆ†)"
        
        if points > 0:
            with transaction.atomic():
                point_record = UserPoints.objects.add_points(
                    member=member,
                    points=points,
                    category='license_activity',
                    subcategory=subcategory,
                    source_type='license',
                    source_id=license_id,
                    description=description,
                    expires_days=365
                )
                
                self._check_and_update_level(member)
                self.permission_service.invalidate_user_permissions_cache(member_id)
            
            logger.info(f"ç”¨æˆ· {member_id} è·å¾—è®¸å¯è¯æ´»åŠ¨ç§¯åˆ† {points} (ç±»å‹: {activity_type})")
            
            return {
                'success': True,
                'points_earned': points,
                'total_points': member.total_points,
                'point_record_id': point_record.id,
            }
        
        return {'success': False, 'reason': 'æœªæ»¡è¶³ç§¯åˆ†è·å–æ¡ä»¶'}
    
    def _check_and_update_level(self, member):
        """æ£€æŸ¥å¹¶æ›´æ–°ç”¨æˆ·ç­‰çº§"""
        from models.user_level import UserLevel
        
        new_level = UserLevel.get_level_by_points(member.total_points)
        if new_level and new_level != member.current_level:
            old_level = member.current_level
            member.current_level = new_level
            member.level_updated_at = timezone.now()
            member.save(update_fields=['current_level', 'level_updated_at'])
            
            # è®°å½•ç­‰çº§å˜æ›´æ—¥å¿—
            logger.info(f"ç”¨æˆ· {member.id} ç­‰çº§å‡çº§: {old_level} -> {new_level}")
            
            # å‘é€ç­‰çº§å‡çº§é€šçŸ¥ (å¼‚æ­¥ä»»åŠ¡)
            from .tasks import send_level_upgrade_notification
            send_level_upgrade_notification.delay(member.id, old_level.id if old_level else None, new_level.id)
            
            return True
        return False
```

## ğŸ”§ å¼‚æ­¥ä»»åŠ¡å®ç°

### 1. ç§¯åˆ†è¿‡æœŸå¤„ç†ä»»åŠ¡
```python
# tasks/points_tasks.py
from celery import shared_task
from django.utils import timezone
from django.db import transaction
import logging

logger = logging.getLogger(__name__)

@shared_task(bind=True, max_retries=3)
def expire_user_points(self, batch_size=1000):
    """å¤„ç†è¿‡æœŸç§¯åˆ†çš„å¼‚æ­¥ä»»åŠ¡"""
    try:
        from models.user_points import UserPoints
        from users.models import Member
        
        # æŸ¥æ‰¾è¿‡æœŸç§¯åˆ†
        expired_points = UserPoints.objects.filter(
            expires_at__lte=timezone.now(),
            status='active',
            point_type='earn'
        )[:batch_size]
        
        if not expired_points:
            logger.info("æ²¡æœ‰éœ€è¦å¤„ç†çš„è¿‡æœŸç§¯åˆ†")
            return {'processed': 0}
        
        expired_count = 0
        affected_members = set()
        
        with transaction.atomic():
            for point_record in expired_points:
                # æ ‡è®°ä¸ºè¿‡æœŸ
                point_record.status = 'expired'
                point_record.expired_at = timezone.now()
                point_record.save(update_fields=['status', 'expired_at'])
                
                affected_members.add(point_record.member_id)
                expired_count += 1
        
        # æ›´æ–°å—å½±å“ç”¨æˆ·çš„å¯ç”¨ç§¯åˆ†
        for member_id in affected_members:
            update_member_available_points.delay(member_id)
        
        logger.info(f"å¤„ç†äº† {expired_count} æ¡è¿‡æœŸç§¯åˆ†è®°å½•ï¼Œå½±å“ {len(affected_members)} ä¸ªç”¨æˆ·")
        
        return {
            'processed': expired_count,
            'affected_members': len(affected_members)
        }
        
    except Exception as exc:
        logger.error(f"å¤„ç†è¿‡æœŸç§¯åˆ†å¤±è´¥: {str(exc)}")
        raise self.retry(exc=exc, countdown=60 * (self.request.retries + 1))

@shared_task
def update_member_available_points(member_id):
    """æ›´æ–°ç”¨æˆ·å¯ç”¨ç§¯åˆ†"""
    try:
        from users.models import Member
        from models.user_points import UserPoints
        
        member = Member.objects.get(id=member_id)
        
        # è®¡ç®—å¯ç”¨ç§¯åˆ†ï¼ˆæ’é™¤å·²è¿‡æœŸçš„ï¼‰
        available_points = UserPoints.objects.filter(
            member=member,
            status='active',
            point_type='earn'
        ).filter(
            models.Q(expires_at__isnull=True) | 
            models.Q(expires_at__gt=timezone.now())
        ).aggregate(
            total=models.Sum('points')
        )['total'] or 0
        
        # æ‰£é™¤å·²æ¶ˆè´¹çš„ç§¯åˆ†
        spent_points = UserPoints.objects.filter(
            member=member,
            point_type='spend',
            status='active'
        ).aggregate(
            total=models.Sum('points')
        )['total'] or 0
        
        available_points += spent_points  # spent_pointsæ˜¯è´Ÿæ•°
        
        # æ›´æ–°ç”¨æˆ·è®°å½•
        member.available_points = max(0, available_points)
        member.last_points_update = timezone.now()
        member.save(update_fields=['available_points', 'last_points_update'])
        
        logger.info(f"æ›´æ–°ç”¨æˆ· {member_id} å¯ç”¨ç§¯åˆ†: {available_points}")
        
    except Exception as exc:
        logger.error(f"æ›´æ–°ç”¨æˆ· {member_id} å¯ç”¨ç§¯åˆ†å¤±è´¥: {str(exc)}")
        raise
```

## ğŸ“Š APIæ¥å£å®ç°

### 1. ç”¨æˆ·æƒé™æŸ¥è¯¢API
```python
# api/views.py
from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response
from drf_spectacular.utils import extend_schema, OpenApiParameter
from .serializers import UserPermissionSerializer
from ..services.permission_service import PermissionService

class UserPermissionViewSet(viewsets.GenericViewSet):
    """ç”¨æˆ·æƒé™API"""
    
    permission_classes = [permissions.IsAuthenticated]
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.permission_service = PermissionService()
    
    @extend_schema(
        summary="è·å–å½“å‰ç”¨æˆ·æƒé™é…ç½®",
        description="è·å–å½“å‰ç”¨æˆ·çš„å®Œæ•´æƒé™é…ç½®ï¼ŒåŒ…æ‹¬ç­‰çº§ã€ç§¯åˆ†ã€é…é¢ç­‰ä¿¡æ¯",
        responses={200: UserPermissionSerializer}
    )
    @action(detail=False, methods=['get'])
    def current(self, request):
        """è·å–å½“å‰ç”¨æˆ·æƒé™é…ç½®"""
        member_id = request.user.id
        permissions = self.permission_service.get_user_permissions(member_id)
        
        serializer = UserPermissionSerializer(permissions)
        return Response({
            'success': True,
            'data': serializer.data
        })
    
    @extend_schema(
        summary="æ£€æŸ¥ç‰¹å®šæƒé™",
        description="æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦æ‹¥æœ‰ç‰¹å®šæƒé™",
        parameters=[
            OpenApiParameter(
                name='permission',
                type=str,
                location=OpenApiParameter.QUERY,
                description='æƒé™é”®åï¼Œæ”¯æŒåµŒå¥—ï¼ˆå¦‚: license_management.batch_requestï¼‰',
                required=True
            )
        ]
    )
    @action(detail=False, methods=['get'])
    def check(self, request):
        """æ£€æŸ¥ç‰¹å®šæƒé™"""
        permission_key = request.query_params.get('permission')
        if not permission_key:
            return Response({
                'success': False,
                'error': 'ç¼ºå°‘permissionå‚æ•°'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        member_id = request.user.id
        has_permission = self.permission_service.check_permission(member_id, permission_key)
        
        return Response({
            'success': True,
            'data': {
                'permission': permission_key,
                'granted': has_permission
            }
        })
    
    @extend_schema(
        summary="åˆ·æ–°æƒé™ç¼“å­˜",
        description="å¼ºåˆ¶åˆ·æ–°å½“å‰ç”¨æˆ·çš„æƒé™ç¼“å­˜"
    )
    @action(detail=False, methods=['post'])
    def refresh(self, request):
        """åˆ·æ–°æƒé™ç¼“å­˜"""
        member_id = request.user.id
        self.permission_service.invalidate_user_permissions_cache(member_id)
        permissions = self.permission_service.get_user_permissions(member_id, force_refresh=True)
        
        return Response({
            'success': True,
            'message': 'æƒé™ç¼“å­˜å·²åˆ·æ–°',
            'data': UserPermissionSerializer(permissions).data
        })
```

---

**ä¸‹ä¸€æ­¥**: æŸ¥çœ‹[è¿ç§»å®æ–½æ–¹æ¡ˆ](18_è¿ç§»å®æ–½æ–¹æ¡ˆ.md)äº†è§£å…·ä½“çš„æ•°æ®è¿ç§»å’Œç³»ç»Ÿå‡çº§è®¡åˆ’
