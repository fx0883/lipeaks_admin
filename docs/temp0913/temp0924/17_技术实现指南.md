# 技术实现指南

## 🎯 技术架构概览

### 系统技术栈
```
后端框架:        Django 4.2 + Django REST Framework
数据库:          PostgreSQL 15 (主库) + Redis 7 (缓存)
消息队列:        Celery + Redis (异步任务)
缓存策略:        Redis (权限缓存) + DB缓存 (查询缓存)
监控日志:        Django Logging + 自定义日志记录
API文档:         drf-spectacular (OpenAPI 3.0)
```

### 核心模块结构
```
user_level_system/
├── models/              # 数据模型
│   ├── __init__.py
│   ├── user_level.py    # 用户等级模型
│   ├── user_points.py   # 积分记录模型
│   ├── user_tags.py     # 用户标签模型
│   └── managers.py      # 自定义Manager
├── services/            # 业务服务层
│   ├── __init__.py
│   ├── points_service.py    # 积分管理服务
│   ├── level_service.py     # 等级管理服务
│   ├── permission_service.py # 权限计算服务
│   └── tag_service.py       # 标签管理服务
├── tasks/               # 异步任务
│   ├── __init__.py
│   ├── points_tasks.py      # 积分相关任务
│   └── level_tasks.py       # 等级相关任务
├── api/                 # API接口
│   ├── __init__.py
│   ├── views.py
│   ├── serializers.py
│   └── permissions.py
├── utils/               # 工具类
│   ├── __init__.py
│   ├── cache.py         # 缓存工具
│   ├── events.py        # 事件处理
│   └── constants.py     # 常量定义
└── tests/              # 测试代码
    ├── test_models.py
    ├── test_services.py
    └── test_api.py
```

## 🗄️ 核心模型实现

### 1. UserLevel模型
```python
# models/user_level.py
from django.db import models
from django.contrib.postgres.fields import JSONField
from django.core.validators import MinValueValidator

class UserLevel(models.Model):
    """用户等级模型"""
    
    level_name = models.CharField('等级名称', max_length=50)
    level_code = models.CharField('等级代码', max_length=20, unique=True)
    level_order = models.PositiveIntegerField('等级顺序', unique=True)
    
    min_points = models.PositiveIntegerField('最小积分', validators=[MinValueValidator(0)])
    max_points = models.PositiveIntegerField('最大积分', null=True, blank=True)
    
    base_permissions = models.JSONField('基础权限', default=dict)
    base_quota_config = models.JSONField('基础配额', default=dict)
    level_benefits = models.JSONField('等级福利', default=dict)
    
    level_icon = models.URLField('等级图标', blank=True)
    level_color = models.CharField('等级颜色', max_length=7, blank=True)
    level_description = models.TextField('等级描述', blank=True)
    
    is_active = models.BooleanField('是否启用', default=True)
    created_at = models.DateTimeField('创建时间', auto_now_add=True)
    updated_at = models.DateTimeField('更新时间', auto_now=True)
    
    class Meta:
        db_table = 'user_level'
        verbose_name = '用户等级'
        verbose_name_plural = '用户等级'
        ordering = ['level_order']
    
    def __str__(self):
        return f"{self.level_name} (Level {self.level_order})"
    
    @classmethod
    def get_level_by_points(cls, points):
        """根据积分获取对应等级"""
        return cls.objects.filter(
            min_points__lte=points,
            is_active=True
        ).filter(
            models.Q(max_points__isnull=True) | models.Q(max_points__gte=points)
        ).order_by('-level_order').first()
    
    def clean(self):
        """模型验证"""
        super().clean()
        if self.max_points and self.max_points < self.min_points:
            raise models.ValidationError('最大积分不能小于最小积分')
```

### 2. UserPoints模型
```python
# models/user_points.py
from django.db import models, transaction
from django.utils import timezone
from django.core.exceptions import ValidationError

class UserPointsManager(models.Manager):
    """积分记录管理器"""
    
    def add_points(self, member, points, category, subcategory=None, 
                   source_type=None, source_id=None, description=None, 
                   expires_days=None):
        """添加积分"""
        if points <= 0:
            raise ValueError("积分数量必须大于0")
        
        with transaction.atomic():
            # 计算过期时间
            expires_at = None
            if expires_days:
                expires_at = timezone.now() + timezone.timedelta(days=expires_days)
            
            # 获取当前余额
            current_balance = member.total_points
            
            # 创建积分记录
            point_record = self.create(
                member=member,
                point_type='earn',
                category=category,
                subcategory=subcategory,
                points=points,
                balance_before=current_balance,
                balance_after=current_balance + points,
                source_type=source_type,
                source_id=source_id,
                operation_reason=description,
                expires_at=expires_at
            )
            
            # 更新用户积分
            member.total_points = models.F('total_points') + points
            member.last_points_update = timezone.now()
            member.save(update_fields=['total_points', 'last_points_update'])
            
            # 刷新数据
            member.refresh_from_db()
            
            return point_record
    
    def spend_points(self, member, points, category, subcategory=None, 
                     description=None):
        """消费积分"""
        if points <= 0:
            raise ValueError("消费积分数量必须大于0")
        
        if member.available_points < points:
            raise ValidationError("可用积分不足")
        
        with transaction.atomic():
            current_balance = member.total_points
            
            point_record = self.create(
                member=member,
                point_type='spend',
                category=category,
                subcategory=subcategory,
                points=-points,  # 消费为负数
                balance_before=current_balance,
                balance_after=current_balance - points,
                operation_reason=description
            )
            
            # 更新用户积分
            member.total_points = models.F('total_points') - points
            member.available_points = models.F('available_points') - points
            member.last_points_update = timezone.now()
            member.save(update_fields=['total_points', 'available_points', 'last_points_update'])
            
            member.refresh_from_db()
            return point_record

class UserPoints(models.Model):
    """用户积分记录"""
    
    POINT_TYPES = [
        ('earn', '获得'),
        ('spend', '消费'),
        ('expire', '过期'),
        ('adjust', '调整'),
    ]
    
    STATUS_CHOICES = [
        ('active', '有效'),
        ('expired', '已过期'),
        ('cancelled', '已取消'),
        ('adjusted', '已调整'),
    ]
    
    member = models.ForeignKey('users.Member', on_delete=models.CASCADE, related_name='point_records')
    
    point_type = models.CharField('积分类型', max_length=10, choices=POINT_TYPES)
    category = models.CharField('业务分类', max_length=50)
    subcategory = models.CharField('子分类', max_length=50, blank=True)
    
    points = models.IntegerField('积分数量')
    balance_before = models.PositiveIntegerField('操作前余额')
    balance_after = models.PositiveIntegerField('操作后余额')
    
    source_type = models.CharField('来源类型', max_length=50, blank=True)
    source_id = models.PositiveIntegerField('来源ID', null=True, blank=True)
    source_description = models.TextField('来源描述', blank=True)
    
    earned_at = models.DateTimeField('获得时间', default=timezone.now)
    expires_at = models.DateTimeField('过期时间', null=True, blank=True)
    expired_at = models.DateTimeField('实际过期时间', null=True, blank=True)
    
    operation_reason = models.TextField('操作原因', blank=True)
    operator = models.ForeignKey('users.User', on_delete=models.SET_NULL, null=True, blank=True)
    batch_id = models.CharField('批次ID', max_length=100, blank=True)
    
    status = models.CharField('状态', max_length=20, choices=STATUS_CHOICES, default='active')
    is_manual = models.BooleanField('是否手动操作', default=False)
    
    created_at = models.DateTimeField('创建时间', auto_now_add=True)
    
    objects = UserPointsManager()
    
    class Meta:
        db_table = 'user_points'
        verbose_name = '用户积分记录'
        verbose_name_plural = '用户积分记录'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['member', '-created_at']),
            models.Index(fields=['point_type', 'category']),
            models.Index(fields=['expires_at'], condition=models.Q(expires_at__isnull=False)),
        ]
    
    def clean(self):
        if self.points == 0:
            raise ValidationError('积分数量不能为0')
        if self.balance_after != self.balance_before + self.points:
            raise ValidationError('积分余额计算错误')
```

## ⚙️ 核心服务实现

### 1. 权限计算服务
```python
# services/permission_service.py
import json
import logging
from typing import Dict, List, Any
from django.core.cache import cache
from django.conf import settings
from .level_service import LevelService
from .tag_service import TagService

logger = logging.getLogger(__name__)

class PermissionService:
    """权限计算服务"""
    
    CACHE_PREFIX = 'user_perms'
    CACHE_TIMEOUT = 30 * 60  # 30分钟
    
    def __init__(self):
        self.level_service = LevelService()
        self.tag_service = TagService()
    
    def get_user_permissions(self, member_id: int, force_refresh: bool = False) -> Dict[str, Any]:
        """获取用户完整权限配置"""
        cache_key = f"{self.CACHE_PREFIX}:{member_id}"
        
        if not force_refresh:
            cached_perms = cache.get(cache_key)
            if cached_perms:
                logger.debug(f"从缓存获取用户 {member_id} 权限")
                return cached_perms
        
        # 计算用户权限
        permissions = self._calculate_user_permissions(member_id)
        
        # 缓存结果
        cache.set(cache_key, permissions, self.CACHE_TIMEOUT)
        logger.info(f"计算并缓存用户 {member_id} 权限")
        
        return permissions
    
    def _calculate_user_permissions(self, member_id: int) -> Dict[str, Any]:
        """计算用户权限"""
        try:
            from users.models import Member
            member = Member.objects.select_related('current_level').get(id=member_id)
        except Member.DoesNotExist:
            logger.error(f"用户 {member_id} 不存在")
            return self._get_default_permissions()
        
        # 1. 获取基础等级权限
        level_permissions, level_quota = self._get_level_permissions(member)
        
        # 2. 获取用户标签权限
        tag_permissions_list, tag_quota_modifiers = self._get_tag_permissions(member)
        
        # 3. 合并权限
        final_permissions = self._merge_permissions(level_permissions, tag_permissions_list)
        
        # 4. 计算最终配额
        final_quota = self._calculate_final_quota(level_quota, tag_quota_modifiers)
        
        return {
            'member_id': member_id,
            'level': {
                'id': member.current_level.id if member.current_level else None,
                'name': member.current_level.level_name if member.current_level else '未设置',
                'code': member.current_level.level_code if member.current_level else 'none',
                'order': member.current_level.level_order if member.current_level else 0,
            },
            'total_points': member.total_points,
            'available_points': member.available_points,
            'permissions': final_permissions,
            'quota': final_quota,
            'tags': self._get_user_tag_info(member),
            'calculated_at': timezone.now().isoformat(),
        }
    
    def _get_level_permissions(self, member) -> tuple:
        """获取等级权限"""
        if not member.current_level:
            # 如果用户没有等级，根据积分计算
            from models.user_level import UserLevel
            level = UserLevel.get_level_by_points(member.total_points)
            if level:
                # 更新用户等级
                member.current_level = level
                member.level_updated_at = timezone.now()
                member.save(update_fields=['current_level', 'level_updated_at'])
        
        if member.current_level:
            return member.current_level.base_permissions, member.current_level.base_quota_config
        else:
            return {}, {}
    
    def _get_tag_permissions(self, member) -> tuple:
        """获取标签权限"""
        active_tags = self.tag_service.get_user_active_tags(member.id)
        
        tag_permissions = []
        tag_quota_modifiers = []
        
        for tag_relation in active_tags:
            tag = tag_relation.tag
            tag_permissions.append(tag.permission_modifiers or {})
            tag_quota_modifiers.append(tag.quota_modifiers or {})
        
        return tag_permissions, tag_quota_modifiers
    
    def _merge_permissions(self, base_permissions: Dict, tag_permissions_list: List[Dict]) -> Dict:
        """合并权限"""
        final_permissions = base_permissions.copy()
        
        for tag_perms in tag_permissions_list:
            final_permissions = self._merge_two_permissions(final_permissions, tag_perms)
        
        return final_permissions
    
    def _merge_two_permissions(self, perm1: Dict, perm2: Dict) -> Dict:
        """合并两个权限配置"""
        result = perm1.copy()
        
        for key, value in perm2.items():
            if key not in result:
                result[key] = value
            else:
                current_value = result[key]
                
                if isinstance(value, bool) and isinstance(current_value, bool):
                    # 布尔权限：OR运算
                    result[key] = current_value or value
                elif isinstance(value, (int, float)) and isinstance(current_value, (int, float)):
                    # 数值权限：取最大值
                    result[key] = max(current_value, value)
                elif isinstance(value, str) and isinstance(current_value, str):
                    # 字符串权限：按优先级
                    priority_map = {
                        "basic": 1, "standard": 2, "advanced": 3, 
                        "premium": 4, "unlimited": 5
                    }
                    if priority_map.get(value, 0) > priority_map.get(current_value, 0):
                        result[key] = value
                elif isinstance(value, dict) and isinstance(current_value, dict):
                    # 字典权限：递归合并
                    result[key] = self._merge_two_permissions(current_value, value)
        
        return result
    
    def _calculate_final_quota(self, base_quota: Dict, tag_quota_modifiers: List[Dict]) -> Dict:
        """计算最终配额"""
        final_quota = base_quota.copy()
        
        # 计算乘数
        license_multiplier = 1.0
        device_multiplier = 1.0
        
        for modifier in tag_quota_modifiers:
            license_multiplier *= modifier.get('license_multiplier', 1.0)
            device_multiplier *= modifier.get('device_multiplier', 1.0)
        
        # 应用乘数（设置合理上限）
        if 'max_licenses' in final_quota:
            final_quota['max_licenses'] = min(
                int(final_quota['max_licenses'] * license_multiplier),
                1000  # 最大1000个许可证
            )
        
        if 'max_devices_per_license' in final_quota:
            final_quota['max_devices_per_license'] = min(
                int(final_quota['max_devices_per_license'] * device_multiplier),
                50  # 最大50个设备
            )
        
        # 处理特殊标签权限
        for modifier in tag_quota_modifiers:
            if modifier.get('unlimited_licenses'):
                final_quota['max_licenses'] = -1  # -1表示无限制
            if modifier.get('unlimited_devices'):
                final_quota['max_devices_per_license'] = -1
        
        return final_quota
    
    def check_permission(self, member_id: int, permission_key: str) -> bool:
        """检查用户是否拥有特定权限"""
        permissions = self.get_user_permissions(member_id)
        return self._get_nested_permission(permissions['permissions'], permission_key)
    
    def _get_nested_permission(self, permissions: Dict, key: str) -> bool:
        """获取嵌套权限值"""
        keys = key.split('.')
        current = permissions
        
        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return False
        
        return bool(current) if not isinstance(current, dict) else False
    
    def invalidate_user_permissions_cache(self, member_id: int):
        """失效用户权限缓存"""
        cache_key = f"{self.CACHE_PREFIX}:{member_id}"
        cache.delete(cache_key)
        logger.info(f"清除用户 {member_id} 权限缓存")
    
    def _get_default_permissions(self) -> Dict[str, Any]:
        """获取默认权限配置"""
        return {
            'member_id': None,
            'level': {'id': None, 'name': '未设置', 'code': 'none', 'order': 0},
            'total_points': 0,
            'available_points': 0,
            'permissions': {'license_request': False},
            'quota': {'max_licenses': 0, 'max_devices_per_license': 0},
            'tags': [],
            'calculated_at': timezone.now().isoformat(),
        }
```

### 2. 积分管理服务
```python
# services/points_service.py
import logging
from datetime import timedelta
from django.utils import timezone
from django.db import transaction
from django.core.exceptions import ValidationError
from .permission_service import PermissionService

logger = logging.getLogger(__name__)

class PointsService:
    """积分管理服务"""
    
    # 积分获取规则配置
    POINTS_RULES = {
        'daily_login': {
            'base_points': 10,
            'max_consecutive_bonus': 50,
            'weekend_bonus': 5,
            'new_user_bonus': 20,  # 注册后7天内
        },
        'license_activity': {
            'first_apply': 50,
            'apply': 30,
            'first_activate': 80,
            'activate_in_week': 30,
            'daily_usage': 5,
            'weekly_active': 50,  # 使用5天+
            'monthly_active': 200,  # 使用20天+
        },
        'social_activity': {
            'useful_post': 50,  # 质量评分≥4.0
            'answer_accepted': 100,
            'get_like': 5,  # 每日最多50分
            'featured_post': 300,
            'valid_bug_report': 200,
            'critical_bug_report': 500,
            'feature_suggestion_accepted': 300,
            'beta_test_participation': 150,
        },
        'payment_activity': {
            'vip_purchase_multiplier': 10,  # 付费金额×10
            'enterprise_certification': 500,
            'referral_enterprise': 1000,
            'annual_renewal_multiplier': 15,  # 年费×15
        }
    }
    
    def __init__(self):
        self.permission_service = PermissionService()
    
    def add_daily_login_points(self, member_id: int) -> Dict[str, Any]:
        """添加每日登录积分"""
        from users.models import Member
        
        try:
            member = Member.objects.get(id=member_id)
        except Member.DoesNotExist:
            raise ValidationError(f"用户 {member_id} 不存在")
        
        # 检查今日是否已经获得登录积分
        today = timezone.now().date()
        today_login_points = member.point_records.filter(
            category='daily_login',
            earned_at__date=today
        ).exists()
        
        if today_login_points:
            return {'success': False, 'reason': '今日已获得登录积分'}
        
        # 计算积分
        points = self._calculate_daily_login_points(member)
        
        # 添加积分
        with transaction.atomic():
            point_record = UserPoints.objects.add_points(
                member=member,
                points=points,
                category='daily_login',
                subcategory='daily_checkin',
                description=f"每日登录奖励 (+{points}分)",
                expires_days=365  # 1年过期
            )
            
            # 检查等级变化
            self._check_and_update_level(member)
            
            # 失效权限缓存
            self.permission_service.invalidate_user_permissions_cache(member_id)
        
        logger.info(f"用户 {member_id} 获得每日登录积分 {points}")
        
        return {
            'success': True,
            'points_earned': points,
            'total_points': member.total_points,
            'point_record_id': point_record.id,
        }
    
    def _calculate_daily_login_points(self, member) -> int:
        """计算每日登录积分"""
        rules = self.POINTS_RULES['daily_login']
        points = rules['base_points']
        
        # 连续登录奖励
        consecutive_days = self._get_consecutive_login_days(member)
        consecutive_bonus = min(consecutive_days * 2, rules['max_consecutive_bonus'])
        points += consecutive_bonus
        
        # 周末奖励
        if timezone.now().weekday() in [5, 6]:  # 周六日
            points += rules['weekend_bonus']
        
        # 新用户奖励
        if (timezone.now().date() - member.created_at.date()).days < 7:
            points += rules['new_user_bonus']
        
        return points
    
    def add_license_activity_points(self, member_id: int, activity_type: str, 
                                   license_id: int = None, **kwargs) -> Dict[str, Any]:
        """添加许可证相关活动积分"""
        from users.models import Member
        
        member = Member.objects.get(id=member_id)
        rules = self.POINTS_RULES['license_activity']
        
        points = 0
        subcategory = activity_type
        description = ""
        
        if activity_type == 'apply':
            # 检查是否首次申请
            is_first_apply = not member.point_records.filter(
                category='license_activity',
                subcategory__in=['first_apply', 'apply']
            ).exists()
            
            if is_first_apply:
                points = rules['first_apply']
                subcategory = 'first_apply'
                description = f"首次申请许可证奖励 (+{points}分)"
            else:
                points = rules['apply']
                description = f"申请许可证奖励 (+{points}分)"
        
        elif activity_type == 'activate':
            # 检查是否首次激活
            is_first_activate = not member.point_records.filter(
                category='license_activity',
                subcategory__in=['first_activate', 'activate']
            ).exists()
            
            if is_first_activate:
                points = rules['first_activate']
                subcategory = 'first_activate'
                description = f"首次激活许可证奖励 (+{points}分)"
            else:
                # 检查是否在7天内激活
                apply_time = kwargs.get('apply_time')
                if apply_time and (timezone.now() - apply_time).days <= 7:
                    points = rules['activate_in_week']
                    description = f"7天内激活许可证奖励 (+{points}分)"
                else:
                    points = 30  # 基础激活奖励
                    description = f"激活许可证奖励 (+{points}分)"
        
        elif activity_type == 'daily_usage':
            # 检查今日是否已获得使用积分
            today = timezone.now().date()
            today_usage_points = member.point_records.filter(
                category='license_activity',
                subcategory='daily_usage',
                earned_at__date=today,
                source_id=license_id
            ).exists()
            
            if today_usage_points:
                return {'success': False, 'reason': '今日该许可证已获得使用积分'}
            
            points = rules['daily_usage']
            description = f"每日使用许可证奖励 (+{points}分)"
        
        if points > 0:
            with transaction.atomic():
                point_record = UserPoints.objects.add_points(
                    member=member,
                    points=points,
                    category='license_activity',
                    subcategory=subcategory,
                    source_type='license',
                    source_id=license_id,
                    description=description,
                    expires_days=365
                )
                
                self._check_and_update_level(member)
                self.permission_service.invalidate_user_permissions_cache(member_id)
            
            logger.info(f"用户 {member_id} 获得许可证活动积分 {points} (类型: {activity_type})")
            
            return {
                'success': True,
                'points_earned': points,
                'total_points': member.total_points,
                'point_record_id': point_record.id,
            }
        
        return {'success': False, 'reason': '未满足积分获取条件'}
    
    def _check_and_update_level(self, member):
        """检查并更新用户等级"""
        from models.user_level import UserLevel
        
        new_level = UserLevel.get_level_by_points(member.total_points)
        if new_level and new_level != member.current_level:
            old_level = member.current_level
            member.current_level = new_level
            member.level_updated_at = timezone.now()
            member.save(update_fields=['current_level', 'level_updated_at'])
            
            # 记录等级变更日志
            logger.info(f"用户 {member.id} 等级升级: {old_level} -> {new_level}")
            
            # 发送等级升级通知 (异步任务)
            from .tasks import send_level_upgrade_notification
            send_level_upgrade_notification.delay(member.id, old_level.id if old_level else None, new_level.id)
            
            return True
        return False
```

## 🔧 异步任务实现

### 1. 积分过期处理任务
```python
# tasks/points_tasks.py
from celery import shared_task
from django.utils import timezone
from django.db import transaction
import logging

logger = logging.getLogger(__name__)

@shared_task(bind=True, max_retries=3)
def expire_user_points(self, batch_size=1000):
    """处理过期积分的异步任务"""
    try:
        from models.user_points import UserPoints
        from users.models import Member
        
        # 查找过期积分
        expired_points = UserPoints.objects.filter(
            expires_at__lte=timezone.now(),
            status='active',
            point_type='earn'
        )[:batch_size]
        
        if not expired_points:
            logger.info("没有需要处理的过期积分")
            return {'processed': 0}
        
        expired_count = 0
        affected_members = set()
        
        with transaction.atomic():
            for point_record in expired_points:
                # 标记为过期
                point_record.status = 'expired'
                point_record.expired_at = timezone.now()
                point_record.save(update_fields=['status', 'expired_at'])
                
                affected_members.add(point_record.member_id)
                expired_count += 1
        
        # 更新受影响用户的可用积分
        for member_id in affected_members:
            update_member_available_points.delay(member_id)
        
        logger.info(f"处理了 {expired_count} 条过期积分记录，影响 {len(affected_members)} 个用户")
        
        return {
            'processed': expired_count,
            'affected_members': len(affected_members)
        }
        
    except Exception as exc:
        logger.error(f"处理过期积分失败: {str(exc)}")
        raise self.retry(exc=exc, countdown=60 * (self.request.retries + 1))

@shared_task
def update_member_available_points(member_id):
    """更新用户可用积分"""
    try:
        from users.models import Member
        from models.user_points import UserPoints
        
        member = Member.objects.get(id=member_id)
        
        # 计算可用积分（排除已过期的）
        available_points = UserPoints.objects.filter(
            member=member,
            status='active',
            point_type='earn'
        ).filter(
            models.Q(expires_at__isnull=True) | 
            models.Q(expires_at__gt=timezone.now())
        ).aggregate(
            total=models.Sum('points')
        )['total'] or 0
        
        # 扣除已消费的积分
        spent_points = UserPoints.objects.filter(
            member=member,
            point_type='spend',
            status='active'
        ).aggregate(
            total=models.Sum('points')
        )['total'] or 0
        
        available_points += spent_points  # spent_points是负数
        
        # 更新用户记录
        member.available_points = max(0, available_points)
        member.last_points_update = timezone.now()
        member.save(update_fields=['available_points', 'last_points_update'])
        
        logger.info(f"更新用户 {member_id} 可用积分: {available_points}")
        
    except Exception as exc:
        logger.error(f"更新用户 {member_id} 可用积分失败: {str(exc)}")
        raise
```

## 📊 API接口实现

### 1. 用户权限查询API
```python
# api/views.py
from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response
from drf_spectacular.utils import extend_schema, OpenApiParameter
from .serializers import UserPermissionSerializer
from ..services.permission_service import PermissionService

class UserPermissionViewSet(viewsets.GenericViewSet):
    """用户权限API"""
    
    permission_classes = [permissions.IsAuthenticated]
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.permission_service = PermissionService()
    
    @extend_schema(
        summary="获取当前用户权限配置",
        description="获取当前用户的完整权限配置，包括等级、积分、配额等信息",
        responses={200: UserPermissionSerializer}
    )
    @action(detail=False, methods=['get'])
    def current(self, request):
        """获取当前用户权限配置"""
        member_id = request.user.id
        permissions = self.permission_service.get_user_permissions(member_id)
        
        serializer = UserPermissionSerializer(permissions)
        return Response({
            'success': True,
            'data': serializer.data
        })
    
    @extend_schema(
        summary="检查特定权限",
        description="检查当前用户是否拥有特定权限",
        parameters=[
            OpenApiParameter(
                name='permission',
                type=str,
                location=OpenApiParameter.QUERY,
                description='权限键名，支持嵌套（如: license_management.batch_request）',
                required=True
            )
        ]
    )
    @action(detail=False, methods=['get'])
    def check(self, request):
        """检查特定权限"""
        permission_key = request.query_params.get('permission')
        if not permission_key:
            return Response({
                'success': False,
                'error': '缺少permission参数'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        member_id = request.user.id
        has_permission = self.permission_service.check_permission(member_id, permission_key)
        
        return Response({
            'success': True,
            'data': {
                'permission': permission_key,
                'granted': has_permission
            }
        })
    
    @extend_schema(
        summary="刷新权限缓存",
        description="强制刷新当前用户的权限缓存"
    )
    @action(detail=False, methods=['post'])
    def refresh(self, request):
        """刷新权限缓存"""
        member_id = request.user.id
        self.permission_service.invalidate_user_permissions_cache(member_id)
        permissions = self.permission_service.get_user_permissions(member_id, force_refresh=True)
        
        return Response({
            'success': True,
            'message': '权限缓存已刷新',
            'data': UserPermissionSerializer(permissions).data
        })
```

---

**下一步**: 查看[迁移实施方案](18_迁移实施方案.md)了解具体的数据迁移和系统升级计划
