# 测试策略

## 🎯 测试目标

### 质量保证
- **功能正确性**: 确保所有功能按照需求规范正确实现
- **性能达标**: 验证系统性能满足预期指标
- **安全性**: 验证系统安全机制的有效性
- **稳定性**: 确保系统在各种条件下稳定运行

### 风险控制
- **回归风险**: 防止新功能影响现有功能
- **集成风险**: 确保各组件正确集成
- **性能风险**: 避免性能退化
- **安全风险**: 防止安全漏洞

## 📊 测试策略矩阵

```
                 ┌─────────────┬─────────────┬─────────────┬─────────────┐
                 │    单元测试  │   集成测试  │   系统测试  │   验收测试  │
┌────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│   功能测试     │     ✓✓✓     │     ✓✓✓     │     ✓✓✓     │     ✓✓✓     │
├────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│   性能测试     │      ✓      │     ✓✓      │     ✓✓✓     │     ✓✓      │
├────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│   安全测试     │      ✓      │     ✓✓      │     ✓✓✓     │     ✓✓      │
├────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│   兼容性测试   │      -      │     ✓✓      │     ✓✓✓     │     ✓✓      │
└────────────────┴─────────────┴─────────────┴─────────────┴─────────────┘

图例: ✓✓✓ 重点关注  ✓✓ 一般关注  ✓ 轻度关注  - 不涉及
```

## 🔧 单元测试策略

### 测试覆盖率目标
```
组件类型           覆盖率目标    重点测试内容
─────────────────  ──────────   ─────────────────────
领域服务层          95%+        业务逻辑、边界条件、异常处理
应用服务层          90%+        服务协调、事务管理、错误处理
数据访问层          95%+        查询逻辑、数据完整性、性能
API控制器层         85%+        请求处理、权限控制、响应格式
```

### 单元测试框架设计

#### 测试基类
```python
import pytest
from unittest.mock import Mock, patch, MagicMock
from django.test import TestCase, TransactionTestCase
from django.db import transaction

class BaseServiceTestCase(TestCase):
    """服务层测试基类"""
    
    def setUp(self):
        """测试环境准备"""
        self.setup_test_data()
        self.setup_mocks()
    
    def setup_test_data(self):
        """设置测试数据"""
        self.test_tenant = self.create_test_tenant()
        self.test_member = self.create_test_member()
        self.test_license = self.create_test_license()
    
    def setup_mocks(self):
        """设置Mock对象"""
        self.mock_repository = Mock()
        self.mock_permission_service = Mock()
        self.mock_audit_service = Mock()
    
    def create_test_tenant(self):
        """创建测试租户"""
        return Tenant.objects.create(
            name="测试租户",
            code="test_tenant",
            is_active=True
        )
    
    def create_test_member(self):
        """创建测试成员"""
        return Member.objects.create(
            username="testuser",
            email="test@example.com",
            tenant=self.test_tenant
        )
    
    def create_test_license(self):
        """创建测试许可证"""
        return License.objects.create(
            license_key="TEST-KEY-123",
            tenant=self.test_tenant,
            max_activations=5,
            status='activated'
        )

class BaseAPITestCase(TestCase):
    """API测试基类"""
    
    def setUp(self):
        """API测试环境准备"""
        self.setup_test_users()
        self.setup_authentication()
    
    def setup_test_users(self):
        """设置测试用户"""
        self.super_admin = User.objects.create_user(
            username="superadmin",
            email="super@example.com",
            is_super_admin=True
        )
        
        self.tenant_admin = User.objects.create_user(
            username="tenantadmin",
            email="tenant@example.com",
            tenant=self.test_tenant,
            is_admin=True
        )
        
        self.normal_member = Member.objects.create_user(
            username="member",
            email="member@example.com",
            tenant=self.test_tenant
        )
    
    def setup_authentication(self):
        """设置认证"""
        from rest_framework_simplejwt.tokens import RefreshToken
        
        # 为不同用户生成JWT Token
        self.super_admin_token = str(RefreshToken.for_user(self.super_admin).access_token)
        self.tenant_admin_token = str(RefreshToken.for_user(self.tenant_admin).access_token)
        self.member_token = str(RefreshToken.for_user(self.normal_member).access_token)
    
    def auth_headers(self, user_type='super_admin'):
        """获取认证头"""
        token_map = {
            'super_admin': self.super_admin_token,
            'tenant_admin': self.tenant_admin_token,
            'member': self.member_token
        }
        return {'HTTP_AUTHORIZATION': f'Bearer {token_map[user_type]}'}
```

#### 领域服务测试示例
```python
class TestLicenseAssignmentDomainService(BaseServiceTestCase):
    """许可证分配领域服务测试"""
    
    def setUp(self):
        super().setUp()
        self.service = LicenseAssignmentDomainService()
        self.service.repository = self.mock_repository
        self.service.permission_service = self.mock_permission_service
        self.service.audit_service = self.mock_audit_service
    
    def test_assign_license_success(self):
        """测试成功分配许可证"""
        # Arrange
        self.mock_permission_service.can_assign_license.return_value = True
        self.mock_repository.check_quota.return_value = True
        self.mock_repository.is_already_assigned.return_value = False
        self.mock_repository.create_assignment.return_value = Mock(id=100)
        
        # Act
        result = self.service.assign_license_to_member(
            member_id=self.test_member.id,
            license_id=self.test_license.id,
            assigned_by_id=1
        )
        
        # Assert
        self.assertTrue(result['success'])
        self.assertEqual(result['assignment_id'], 100)
        
        # 验证调用顺序
        self.mock_permission_service.can_assign_license.assert_called_once()
        self.mock_repository.check_quota.assert_called_once()
        self.mock_repository.is_already_assigned.assert_called_once()
        self.mock_repository.create_assignment.assert_called_once()
        self.mock_audit_service.log_assignment_operation.assert_called_once()
    
    def test_assign_license_permission_denied(self):
        """测试权限不足的情况"""
        # Arrange
        self.mock_permission_service.can_assign_license.return_value = False
        
        # Act & Assert
        with self.assertRaises(PermissionDeniedException):
            self.service.assign_license_to_member(
                member_id=self.test_member.id,
                license_id=self.test_license.id,
                assigned_by_id=1
            )
        
        # 验证没有执行后续操作
        self.mock_repository.check_quota.assert_not_called()
    
    def test_assign_license_quota_exceeded(self):
        """测试配额超限的情况"""
        # Arrange
        self.mock_permission_service.can_assign_license.return_value = True
        self.mock_repository.check_quota.return_value = False
        self.mock_repository.get_quota_info.return_value = (5, 5)
        
        # Act & Assert
        with self.assertRaises(QuotaExceededException) as context:
            self.service.assign_license_to_member(
                member_id=self.test_member.id,
                license_id=self.test_license.id
            )
        
        # 验证异常详情
        exception = context.exception
        self.assertEqual(exception.error_code, 'QUOTA_EXCEEDED')
        self.assertEqual(exception.details['license_id'], self.test_license.id)
    
    @patch('licenses.services.timezone.now')
    def test_assign_license_with_expiry(self, mock_now):
        """测试带过期时间的分配"""
        # Arrange
        mock_now.return_value = datetime(2024, 9, 24, 10, 0, 0, tzinfo=timezone.utc)
        expected_expiry = datetime(2024, 12, 24, 10, 0, 0, tzinfo=timezone.utc)
        
        self.mock_permission_service.can_assign_license.return_value = True
        self.mock_repository.check_quota.return_value = True
        self.mock_repository.is_already_assigned.return_value = False
        
        # Act
        result = self.service.assign_license_to_member(
            member_id=self.test_member.id,
            license_id=self.test_license.id,
            expires_days=90
        )
        
        # Assert
        self.assertTrue(result['success'])
        
        # 验证过期时间计算
        call_args = self.mock_repository.create_assignment.call_args[1]
        self.assertEqual(call_args['expires_at'], expected_expiry)
```

#### API测试示例
```python
class TestLicenseAssignmentAPI(BaseAPITestCase):
    """许可证分配API测试"""
    
    def test_create_assignment_success(self):
        """测试成功创建分配"""
        # Arrange
        data = {
            'member_id': self.test_member.id,
            'license_id': self.test_license.id,
            'assignment_type': 'direct',
            'max_concurrent_devices': 3
        }
        
        # Act
        response = self.client.post(
            '/api/v1/license-assignments/',
            data=data,
            content_type='application/json',
            **self.auth_headers('super_admin')
        )
        
        # Assert
        self.assertEqual(response.status_code, 201)
        self.assertTrue(response.json()['success'])
        self.assertIn('assignment_id', response.json()['data'])
        
        # 验证数据库记录
        assignment = LicenseAssignment.objects.get(
            id=response.json()['data']['assignment_id']
        )
        self.assertEqual(assignment.member_id, self.test_member.id)
        self.assertEqual(assignment.license_id, self.test_license.id)
    
    def test_create_assignment_permission_denied(self):
        """测试权限不足"""
        # Arrange
        data = {
            'member_id': self.test_member.id,
            'license_id': self.test_license.id
        }
        
        # Act - 使用普通成员token
        response = self.client.post(
            '/api/v1/license-assignments/',
            data=data,
            content_type='application/json',
            **self.auth_headers('member')
        )
        
        # Assert
        self.assertEqual(response.status_code, 403)
    
    def test_get_assignments_list(self):
        """测试获取分配列表"""
        # Arrange - 创建测试数据
        assignment = LicenseAssignment.objects.create(
            member=self.test_member,
            license=self.test_license,
            status='active'
        )
        
        # Act
        response = self.client.get(
            '/api/v1/license-assignments/',
            **self.auth_headers('super_admin')
        )
        
        # Assert
        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertTrue(data['success'])
        self.assertGreater(data['data']['count'], 0)
        
        # 验证返回数据格式
        first_assignment = data['data']['results'][0]
        self.assertIn('id', first_assignment)
        self.assertIn('member', first_assignment)
        self.assertIn('license', first_assignment)
        self.assertIn('status', first_assignment)
    
    def test_batch_assign_licenses(self):
        """测试批量分配许可证"""
        # Arrange
        member2 = Member.objects.create(
            username="testuser2",
            email="test2@example.com",
            tenant=self.test_tenant
        )
        
        data = {
            'assignments': [
                {
                    'member_id': self.test_member.id,
                    'license_id': self.test_license.id,
                    'assignment_type': 'group'
                },
                {
                    'member_id': member2.id,
                    'license_id': self.test_license.id,
                    'assignment_type': 'group'
                }
            ],
            'common_settings': {
                'expires_days': 365,
                'assignment_notes': '批量分配测试'
            }
        }
        
        # Act
        response = self.client.post(
            '/api/v1/license-assignments/batch-assign/',
            data=data,
            content_type='application/json',
            **self.auth_headers('super_admin')
        )
        
        # Assert
        self.assertEqual(response.status_code, 200)
        result = response.json()
        self.assertTrue(result['success'])
        self.assertEqual(len(result['results']), 2)
        
        # 验证数据库记录
        assignments = LicenseAssignment.objects.filter(
            license=self.test_license,
            assignment_notes__contains='批量分配测试'
        )
        self.assertEqual(assignments.count(), 2)
```

## 🔄 集成测试策略

### 测试场景设计

#### 跨服务集成测试
```python
class TestLicenseAssignmentIntegration(TransactionTestCase):
    """许可证分配集成测试"""
    
    def setUp(self):
        """集成测试环境准备"""
        self.setup_test_environment()
        self.setup_real_services()
    
    def setup_real_services(self):
        """设置真实服务实例"""
        self.domain_service = LicenseAssignmentDomainService()
        self.application_service = LicenseManagementApplicationService()
        self.permission_service = PermissionValidationService()
        self.audit_service = AuditLogService()
    
    def test_complete_assignment_workflow(self):
        """测试完整的分配工作流"""
        # 1. 创建分配请求
        assignment_data = {
            'member_id': self.test_member.id,
            'license_id': self.test_license.id,
            'assigned_by_id': self.test_admin.id,
            'assignment_type': 'direct',
            'expires_days': 365
        }
        
        # 2. 执行分配
        result = self.application_service.assign_license_to_member(assignment_data)
        
        # 3. 验证分配成功
        self.assertTrue(result['success'])
        assignment_id = result['assignment_id']
        
        # 4. 验证数据库状态
        assignment = LicenseAssignment.objects.get(id=assignment_id)
        self.assertEqual(assignment.status, 'assigned')
        self.assertEqual(assignment.member, self.test_member)
        self.assertEqual(assignment.license, self.test_license)
        
        # 5. 测试激活流程
        activation_result = self.application_service.activate_assignment(
            assignment_id=assignment_id,
            device_info={
                'device_id': 'TEST-DEVICE-001',
                'hardware_fingerprint': 'test-fingerprint-123'
            }
        )
        
        # 6. 验证激活成功
        self.assertTrue(activation_result['success'])
        
        # 7. 验证状态变更
        assignment.refresh_from_db()
        self.assertEqual(assignment.status, 'active')
        self.assertIsNotNone(assignment.activated_at)
        
        # 8. 验证审计日志
        audit_logs = SecurityAuditLog.objects.filter(
            details__assignment_id=assignment_id
        )
        self.assertGreater(audit_logs.count(), 0)
    
    def test_quota_enforcement_integration(self):
        """测试配额强制执行的集成"""
        # 1. 设置许可证最大激活数为2
        self.test_license.max_activations = 2
        self.test_license.save()
        
        # 2. 创建第一个分配 - 应该成功
        result1 = self.application_service.assign_license_to_member({
            'member_id': self.test_member.id,
            'license_id': self.test_license.id,
            'assigned_by_id': self.test_admin.id
        })
        self.assertTrue(result1['success'])
        
        # 3. 创建第二个成员和分配 - 应该成功
        member2 = Member.objects.create(
            username="testuser2",
            email="test2@example.com",
            tenant=self.test_tenant
        )
        
        result2 = self.application_service.assign_license_to_member({
            'member_id': member2.id,
            'license_id': self.test_license.id,
            'assigned_by_id': self.test_admin.id
        })
        self.assertTrue(result2['success'])
        
        # 4. 创建第三个成员和分配 - 应该失败
        member3 = Member.objects.create(
            username="testuser3",
            email="test3@example.com",
            tenant=self.test_tenant
        )
        
        result3 = self.application_service.assign_license_to_member({
            'member_id': member3.id,
            'license_id': self.test_license.id,
            'assigned_by_id': self.test_admin.id
        })
        self.assertFalse(result3['success'])
        self.assertIn('配额', result3['error'])
    
    def test_tenant_isolation_integration(self):
        """测试租户隔离的集成"""
        # 1. 创建另一个租户和相关数据
        other_tenant = Tenant.objects.create(
            name="其他租户",
            code="other_tenant"
        )
        
        other_member = Member.objects.create(
            username="otheruser",
            email="other@example.com", 
            tenant=other_tenant
        )
        
        # 2. 尝试跨租户分配 - 应该失败
        result = self.application_service.assign_license_to_member({
            'member_id': other_member.id,  # 不同租户的成员
            'license_id': self.test_license.id,  # 原租户的许可证
            'assigned_by_id': self.test_admin.id
        })
        
        # 3. 验证失败
        self.assertFalse(result['success'])
        self.assertIn('租户', result['error'])
        
        # 4. 验证没有创建分配记录
        assignments = LicenseAssignment.objects.filter(
            member=other_member,
            license=self.test_license
        )
        self.assertEqual(assignments.count(), 0)
```

## ⚡ 性能测试策略

### 性能测试场景

#### 负载测试
```python
import time
import concurrent.futures
from django.test import TestCase
from django.test.utils import override_settings

class TestLicenseAssignmentPerformance(TestCase):
    """许可证分配性能测试"""
    
    def setUp(self):
        self.setup_performance_test_data()
    
    def setup_performance_test_data(self):
        """设置性能测试数据"""
        # 创建大量测试数据
        self.tenant = Tenant.objects.create(name="性能测试租户")
        
        # 创建1000个成员
        self.members = []
        for i in range(1000):
            member = Member.objects.create(
                username=f"perfuser{i}",
                email=f"perf{i}@example.com",
                tenant=self.tenant
            )
            self.members.append(member)
        
        # 创建100个许可证
        self.licenses = []
        for i in range(100):
            license = License.objects.create(
                license_key=f"PERF-KEY-{i:03d}",
                tenant=self.tenant,
                max_activations=50
            )
            self.licenses.append(license)
    
    def test_batch_assignment_performance(self):
        """测试批量分配性能"""
        # 测试场景：同时分配100个许可证给100个用户
        start_time = time.time()
        
        service = LicenseManagementApplicationService()
        
        # 准备批量分配数据
        assignments_data = []
        for i in range(100):
            assignments_data.append({
                'member_id': self.members[i].id,
                'license_id': self.licenses[i % 10].id,  # 重复使用前10个许可证
                'assignment_type': 'direct'
            })
        
        # 执行批量分配
        result = service.batch_assign_licenses(assignments_data)
        
        end_time = time.time()
        execution_time = end_time - start_time
        
        # 性能断言
        self.assertTrue(result['success'])
        self.assertLess(execution_time, 5.0)  # 应该在5秒内完成
        
        # 验证分配成功
        successful_assignments = sum(1 for r in result['results'] if r['success'])
        self.assertGreater(successful_assignments, 90)  # 至少90%成功率
    
    def test_concurrent_assignment_performance(self):
        """测试并发分配性能"""
        def assign_license(member_license_pair):
            """单个分配操作"""
            member, license = member_license_pair
            service = LicenseManagementApplicationService()
            return service.assign_license_to_member({
                'member_id': member.id,
                'license_id': license.id,
                'assignment_type': 'concurrent_test'
            })
        
        # 准备并发测试数据
        test_pairs = []
        for i in range(50):
            test_pairs.append((
                self.members[i],
                self.licenses[0]  # 所有请求都尝试分配同一个许可证
            ))
        
        start_time = time.time()
        
        # 使用线程池执行并发分配
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(assign_license, pair) for pair in test_pairs]
            results = [future.result() for future in concurrent.futures.as_completed(futures)]
        
        end_time = time.time()
        execution_time = end_time - start_time
        
        # 性能断言
        self.assertLess(execution_time, 10.0)  # 应该在10秒内完成
        
        # 验证并发控制
        successful_results = [r for r in results if r['success']]
        # 由于配额限制，成功的分配数量应该小于等于许可证的最大激活数
        self.assertLessEqual(len(successful_results), self.licenses[0].max_activations)
    
    def test_query_performance(self):
        """测试查询性能"""
        # 先创建大量分配记录
        assignments = []
        for i in range(1000):
            assignment = LicenseAssignment.objects.create(
                member=self.members[i % len(self.members)],
                license=self.licenses[i % len(self.licenses)],
                status='active'
            )
            assignments.append(assignment)
        
        repository = LicenseAssignmentRepository()
        
        # 测试按成员查询性能
        start_time = time.time()
        for i in range(100):
            member_assignments = repository.find_by_member_with_details(
                self.members[i].id
            )
            list(member_assignments)  # 强制执行查询
        
        query_time = time.time() - start_time
        
        # 性能断言
        self.assertLess(query_time, 2.0)  # 100次查询应该在2秒内完成
        
        # 测试统计查询性能
        start_time = time.time()
        stats = repository.get_assignment_statistics(self.tenant.id)
        stats_time = time.time() - start_time
        
        self.assertLess(stats_time, 0.5)  # 统计查询应该在0.5秒内完成
```

### 压力测试
```python
class TestSystemStressTest(TestCase):
    """系统压力测试"""
    
    @override_settings(DEBUG=False)
    def test_high_load_assignment_stress(self):
        """高负载分配压力测试"""
        # 模拟高并发场景下的系统行为
        
        # 创建大量测试数据
        tenant = Tenant.objects.create(name="压力测试租户")
        
        # 创建5000个成员
        Member.objects.bulk_create([
            Member(
                username=f"stressuser{i}",
                email=f"stress{i}@example.com",
                tenant=tenant
            ) for i in range(5000)
        ])
        
        # 创建500个许可证，每个许可证允许100个激活
        License.objects.bulk_create([
            License(
                license_key=f"STRESS-KEY-{i:04d}",
                tenant=tenant,
                max_activations=100,
                status='activated'
            ) for i in range(500)
        ])
        
        members = Member.objects.filter(tenant=tenant)
        licenses = License.objects.filter(tenant=tenant)
        
        def stress_assignment_operation():
            """压力测试操作"""
            import random
            service = LicenseManagementApplicationService()
            
            # 随机选择成员和许可证
            member = random.choice(members)
            license = random.choice(licenses)
            
            try:
                result = service.assign_license_to_member({
                    'member_id': member.id,
                    'license_id': license.id,
                    'assignment_type': 'stress_test'
                })
                return result['success']
            except Exception:
                return False
        
        # 执行压力测试
        start_time = time.time()
        success_count = 0
        total_operations = 1000
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            futures = [
                executor.submit(stress_assignment_operation) 
                for _ in range(total_operations)
            ]
            
            for future in concurrent.futures.as_completed(futures):
                if future.result():
                    success_count += 1
        
        end_time = time.time()
        execution_time = end_time - start_time
        
        # 压力测试评估
        success_rate = success_count / total_operations
        throughput = total_operations / execution_time
        
        # 断言系统在压力下的表现
        self.assertGreater(success_rate, 0.8)  # 成功率应该大于80%
        self.assertGreater(throughput, 20)     # 吞吐量应该大于20 ops/sec
        self.assertLess(execution_time, 60)    # 总时间应该小于60秒
        
        print(f"压力测试结果:")
        print(f"  成功率: {success_rate:.2%}")
        print(f"  吞吐量: {throughput:.2f} ops/sec")
        print(f"  执行时间: {execution_time:.2f} seconds")
```

## 🔒 安全测试策略

### 权限控制测试
```python
class TestSecurityAndPermissions(BaseAPITestCase):
    """安全和权限测试"""
    
    def test_unauthorized_access_blocked(self):
        """测试未授权访问被阻止"""
        # 测试无Token访问
        response = self.client.get('/api/v1/license-assignments/')
        self.assertEqual(response.status_code, 401)
        
        # 测试无效Token访问
        response = self.client.get(
            '/api/v1/license-assignments/',
            HTTP_AUTHORIZATION='Bearer invalid-token'
        )
        self.assertEqual(response.status_code, 401)
    
    def test_cross_tenant_access_blocked(self):
        """测试跨租户访问被阻止"""
        # 创建另一个租户的数据
        other_tenant = Tenant.objects.create(name="其他租户")
        other_member = Member.objects.create(
            username="otheruser",
            email="other@example.com",
            tenant=other_tenant
        )
        other_license = License.objects.create(
            license_key="OTHER-KEY-123",
            tenant=other_tenant
        )
        other_assignment = LicenseAssignment.objects.create(
            member=other_member,
            license=other_license
        )
        
        # 租户管理员尝试访问其他租户的数据
        response = self.client.get(
            f'/api/v1/license-assignments/{other_assignment.id}/',
            **self.auth_headers('tenant_admin')
        )
        
        # 应该被拒绝或返回404
        self.assertIn(response.status_code, [403, 404])
    
    def test_privilege_escalation_blocked(self):
        """测试权限提升被阻止"""
        # 普通成员尝试创建分配
        data = {
            'member_id': self.test_member.id,
            'license_id': self.test_license.id
        }
        
        response = self.client.post(
            '/api/v1/license-assignments/',
            data=data,
            content_type='application/json',
            **self.auth_headers('member')
        )
        
        self.assertEqual(response.status_code, 403)
    
    def test_input_validation_security(self):
        """测试输入验证安全性"""
        # SQL注入尝试
        malicious_data = {
            'member_id': "1; DROP TABLE license_assignment; --",
            'license_id': self.test_license.id
        }
        
        response = self.client.post(
            '/api/v1/license-assignments/',
            data=malicious_data,
            content_type='application/json',
            **self.auth_headers('super_admin')
        )
        
        # 应该返回400错误，而不是执行恶意SQL
        self.assertEqual(response.status_code, 400)
        
        # XSS尝试
        xss_data = {
            'member_id': self.test_member.id,
            'license_id': self.test_license.id,
            'assignment_notes': '<script>alert("XSS")</script>'
        }
        
        response = self.client.post(
            '/api/v1/license-assignments/',
            data=xss_data,
            content_type='application/json',
            **self.auth_headers('super_admin')
        )
        
        if response.status_code == 201:
            # 检查返回的数据是否被正确转义
            assignment_id = response.json()['data']['assignment_id']
            assignment = LicenseAssignment.objects.get(id=assignment_id)
            self.assertNotIn('<script>', assignment.assignment_notes)
```

## 📊 测试执行和报告

### 自动化测试流程
```python
# pytest配置文件 - pytest.ini
[tool:pytest]
DJANGO_SETTINGS_MODULE = core.settings_test
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    --verbose
    --tb=short
    --cov=licenses
    --cov-report=html
    --cov-report=term-missing
    --cov-fail-under=85
    --maxfail=10
markers =
    unit: Unit tests
    integration: Integration tests  
    performance: Performance tests
    security: Security tests
    slow: Slow running tests
```

### 测试报告模板
```python
class TestReportGenerator:
    """测试报告生成器"""
    
    def generate_test_report(self, test_results):
        """生成测试报告"""
        report = {
            'summary': {
                'total_tests': test_results['total'],
                'passed': test_results['passed'],
                'failed': test_results['failed'],
                'skipped': test_results['skipped'],
                'success_rate': test_results['passed'] / test_results['total'],
                'execution_time': test_results['duration']
            },
            'coverage': {
                'overall': test_results['coverage']['total'],
                'by_component': test_results['coverage']['by_file']
            },
            'performance_metrics': {
                'avg_response_time': test_results['performance']['avg_response'],
                'max_response_time': test_results['performance']['max_response'],
                'throughput': test_results['performance']['throughput']
            },
            'security_checks': {
                'authentication': test_results['security']['auth_tests'],
                'authorization': test_results['security']['authz_tests'],
                'input_validation': test_results['security']['validation_tests']
            }
        }
        
        return report
```

### 持续集成配置
```yaml
# CI/CD 流水线配置示例
name: License Assignment Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_DB: lipeaks_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: 3.9
    
    - name: Install dependencies
      run: |
        pip install -r requirements-test.txt
    
    - name: Run unit tests
      run: |
        pytest tests/unit/ -m "unit" --cov=licenses
    
    - name: Run integration tests  
      run: |
        pytest tests/integration/ -m "integration"
    
    - name: Run performance tests
      run: |
        pytest tests/performance/ -m "performance"
    
    - name: Run security tests
      run: |
        pytest tests/security/ -m "security"
    
    - name: Generate test report
      run: |
        pytest --html=report.html --self-contained-html
    
    - name: Upload test results
      uses: actions/upload-artifact@v2
      with:
        name: test-results
        path: report.html
```

## 🎯 测试成功标准

### 测试覆盖率标准
- **整体覆盖率**: ≥ 85%
- **关键业务逻辑**: ≥ 95%
- **API端点**: ≥ 80%
- **错误处理**: ≥ 90%

### 性能标准
- **API响应时间**: 95%请求 < 500ms
- **数据库查询**: 平均 < 100ms
- **并发处理**: 支持1000+并发用户
- **系统吞吐量**: ≥ 100 requests/second

### 安全标准
- **权限控制**: 100%测试通过
- **输入验证**: 100%测试通过
- **租户隔离**: 100%测试通过
- **安全漏洞**: 0个高危漏洞

---

**实施完成**: 至此，许可证与成员用户关联的领域服务模式完整实施方案已经制定完毕。请按照文档顺序实施，确保每个阶段的质量标准。
