# 最佳实践

## 🎯 开发规范

### 代码质量标准

#### 命名规范
```python
# 类名：使用帕斯卡命名法
class LicenseAssignmentDomainService:
    pass

# 方法名：使用蛇形命名法，动词开头
def assign_license_to_member(self, member_id: int, license_id: int):
    pass

# 变量名：使用蛇形命名法，名词优先
assignment_count = 0
user_licenses = []

# 常量：全大写，下划线分隔
MAX_ASSIGNMENT_RETRY_COUNT = 3
DEFAULT_ASSIGNMENT_EXPIRES_DAYS = 365
```

#### 注释和文档规范
```python
class LicenseAssignmentDomainService:
    """
    许可证分配领域服务
    
    职责：
    - 处理许可证与用户的分配逻辑
    - 管理分配状态的生命周期
    - 控制分配配额和限制
    - 验证分配的业务规则
    
    设计原则：
    - 无状态服务，不保存内部状态
    - 单一职责，只处理分配相关业务
    - 依赖注入，便于测试和扩展
    """
    
    def assign_license_to_member(
        self, 
        member_id: int, 
        license_id: int,
        assigned_by_id: int = None,
        **kwargs
    ) -> Dict[str, Any]:
        """
        将许可证分配给指定成员
        
        Args:
            member_id: 成员用户ID
            license_id: 许可证ID  
            assigned_by_id: 分配操作人员ID (可选)
            **kwargs: 其他分配参数
                - assignment_type: 分配类型
                - expires_days: 有效天数
                - max_devices: 最大设备数
                - notes: 备注信息
        
        Returns:
            Dict[str, Any]: 操作结果
            {
                'success': bool,           # 操作是否成功
                'assignment_id': int,      # 分配记录ID (成功时)
                'message': str,            # 操作消息
                'error': str              # 错误信息 (失败时)
            }
        
        Raises:
            ValidationError: 参数验证失败
            PermissionDenied: 权限不足
            BusinessRuleError: 业务规则违反
        
        Examples:
            >>> service = LicenseAssignmentDomainService()
            >>> result = service.assign_license_to_member(
            ...     member_id=10,
            ...     license_id=5,
            ...     assigned_by_id=1,
            ...     assignment_type='direct'
            ... )
            >>> print(result['success'])
            True
        """
        # 实现逻辑...
```

#### 类型注解规范
```python
from typing import Dict, List, Optional, Union, Any
from datetime import datetime

class LicenseAssignmentService:
    def create_assignment(
        self,
        assignment_data: Dict[str, Any]
    ) -> LicenseAssignment:
        """创建分配记录"""
        pass
    
    def find_assignments_by_criteria(
        self,
        member_id: Optional[int] = None,
        license_id: Optional[int] = None,
        status_list: Optional[List[str]] = None,
        date_range: Optional[tuple[datetime, datetime]] = None
    ) -> List[LicenseAssignment]:
        """根据条件查找分配记录"""
        pass
    
    def get_assignment_statistics(
        self,
        tenant_id: int
    ) -> Dict[str, Union[int, float, str]]:
        """获取分配统计信息"""
        pass
```

### 错误处理最佳实践

#### 异常层次设计
```python
# 基础异常类
class LicenseAssignmentException(Exception):
    """许可证分配基础异常"""
    
    def __init__(self, message: str, error_code: str = None, details: Dict = None):
        self.message = message
        self.error_code = error_code or self.__class__.__name__
        self.details = details or {}
        super().__init__(self.message)

# 业务异常类
class QuotaExceededException(LicenseAssignmentException):
    """配额超限异常"""
    
    def __init__(self, license_id: int, current_count: int, max_count: int):
        message = f"许可证 {license_id} 分配配额已满 ({current_count}/{max_count})"
        details = {
            'license_id': license_id,
            'current_count': current_count,
            'max_count': max_count
        }
        super().__init__(message, 'QUOTA_EXCEEDED', details)

class DuplicateAssignmentException(LicenseAssignmentException):
    """重复分配异常"""
    
    def __init__(self, member_id: int, license_id: int):
        message = f"成员 {member_id} 已经拥有许可证 {license_id}"
        details = {'member_id': member_id, 'license_id': license_id}
        super().__init__(message, 'DUPLICATE_ASSIGNMENT', details)

# 使用示例
class LicenseAssignmentDomainService:
    def assign_license_to_member(self, member_id: int, license_id: int):
        try:
            # 检查配额
            if not self._check_quota(license_id):
                current, max_count = self._get_quota_info(license_id)
                raise QuotaExceededException(license_id, current, max_count)
            
            # 检查重复分配
            if self._is_already_assigned(member_id, license_id):
                raise DuplicateAssignmentException(member_id, license_id)
            
            # 执行分配逻辑
            return self._create_assignment(member_id, license_id)
            
        except LicenseAssignmentException:
            # 重新抛出业务异常
            raise
        except Exception as e:
            # 包装系统异常
            logger.error(f"许可证分配系统错误: {str(e)}")
            raise LicenseAssignmentException(
                "系统错误，请稍后重试",
                "SYSTEM_ERROR",
                {'original_error': str(e)}
            )
```

#### 错误日志记录
```python
import logging
from datetime import datetime

# 配置专用的业务日志记录器
business_logger = logging.getLogger('license_assignment.business')
security_logger = logging.getLogger('license_assignment.security')
performance_logger = logging.getLogger('license_assignment.performance')

class AuditLogService:
    def log_assignment_operation(
        self,
        operation: str,
        user_id: int,
        assignment_id: int = None,
        success: bool = True,
        error_message: str = None,
        execution_time: float = None
    ):
        """记录分配操作日志"""
        
        log_data = {
            'timestamp': datetime.now().isoformat(),
            'operation': operation,
            'user_id': user_id,
            'assignment_id': assignment_id,
            'success': success,
            'execution_time_ms': execution_time * 1000 if execution_time else None
        }
        
        if success:
            business_logger.info(
                f"分配操作成功: {operation}",
                extra=log_data
            )
        else:
            business_logger.error(
                f"分配操作失败: {operation} - {error_message}",
                extra={**log_data, 'error_message': error_message}
            )
        
        # 性能日志
        if execution_time and execution_time > 1.0:  # 超过1秒
            performance_logger.warning(
                f"分配操作性能告警: {operation}",
                extra=log_data
            )
```

### 测试最佳实践

#### 单元测试规范
```python
import pytest
from unittest.mock import Mock, patch
from django.test import TestCase

class TestLicenseAssignmentDomainService(TestCase):
    """许可证分配领域服务测试"""
    
    def setUp(self):
        """测试准备"""
        self.service = LicenseAssignmentDomainService()
        self.mock_repository = Mock()
        self.service.repository = self.mock_repository
        
        # 测试数据准备
        self.test_member_id = 10
        self.test_license_id = 5
        self.test_assigned_by_id = 1
    
    def test_assign_license_success(self):
        """测试成功分配许可证"""
        # Arrange
        self.mock_repository.check_quota.return_value = True
        self.mock_repository.is_already_assigned.return_value = False
        self.mock_repository.create_assignment.return_value = Mock(id=100)
        
        # Act
        result = self.service.assign_license_to_member(
            self.test_member_id,
            self.test_license_id,
            self.test_assigned_by_id
        )
        
        # Assert
        self.assertTrue(result['success'])
        self.assertEqual(result['assignment_id'], 100)
        self.mock_repository.create_assignment.assert_called_once()
    
    def test_assign_license_quota_exceeded(self):
        """测试配额超限情况"""
        # Arrange
        self.mock_repository.check_quota.return_value = False
        self.mock_repository.get_quota_info.return_value = (5, 5)
        
        # Act & Assert
        with self.assertRaises(QuotaExceededException) as context:
            self.service.assign_license_to_member(
                self.test_member_id,
                self.test_license_id
            )
        
        self.assertEqual(context.exception.error_code, 'QUOTA_EXCEEDED')
    
    def test_assign_license_duplicate_assignment(self):
        """测试重复分配情况"""
        # Arrange
        self.mock_repository.check_quota.return_value = True
        self.mock_repository.is_already_assigned.return_value = True
        
        # Act & Assert
        with self.assertRaises(DuplicateAssignmentException):
            self.service.assign_license_to_member(
                self.test_member_id,
                self.test_license_id
            )
```

#### 集成测试规范
```python
class TestLicenseAssignmentIntegration(TestCase):
    """许可证分配集成测试"""
    
    def setUp(self):
        """创建测试数据"""
        self.tenant = Tenant.objects.create(name="测试租户")
        self.member = Member.objects.create(
            username="testuser",
            email="test@example.com",
            tenant=self.tenant
        )
        self.license = License.objects.create(
            license_key="TEST-KEY-123",
            tenant=self.tenant,
            max_activations=5
        )
    
    def test_full_assignment_workflow(self):
        """测试完整的分配工作流"""
        # 1. 分配许可证
        service = LicenseAssignmentDomainService()
        result = service.assign_license_to_member(
            member_id=self.member.id,
            license_id=self.license.id
        )
        
        self.assertTrue(result['success'])
        assignment_id = result['assignment_id']
        
        # 2. 验证分配记录创建
        assignment = LicenseAssignment.objects.get(id=assignment_id)
        self.assertEqual(assignment.member, self.member)
        self.assertEqual(assignment.license, self.license)
        self.assertEqual(assignment.status, 'assigned')
        
        # 3. 激活许可证
        activation_result = service.activate_assignment(
            assignment_id=assignment_id,
            device_info={'device_id': 'TEST-DEVICE-001'}
        )
        
        self.assertTrue(activation_result['success'])
        
        # 4. 验证状态变更
        assignment.refresh_from_db()
        self.assertEqual(assignment.status, 'active')
        self.assertIsNotNone(assignment.activated_at)
```

### 性能优化最佳实践

#### 数据库查询优化
```python
class OptimizedQueryPatterns:
    """优化的查询模式"""
    
    def get_user_assignments_with_details(self, member_id: int):
        """获取用户分配详情 - 优化版本"""
        # 使用select_related减少查询次数
        return LicenseAssignment.objects.select_related(
            'license',
            'license__product',
            'license__plan',
            'member',
            'assigned_by'
        ).prefetch_related(
            'license__machine_bindings'
        ).filter(
            member_id=member_id,
            is_deleted=False
        ).order_by('-assigned_at')
    
    def get_expiring_assignments_batch(self, days: int):
        """批量获取即将过期的分配 - 使用迭代器避免内存问题"""
        from django.utils import timezone
        from datetime import timedelta
        
        expiry_date = timezone.now() + timedelta(days=days)
        
        return LicenseAssignment.objects.filter(
            expires_at__lte=expiry_date,
            status__in=['assigned', 'active'],
            is_deleted=False
        ).select_related('license', 'member').iterator(chunk_size=1000)
    
    def get_license_utilization_stats(self, tenant_id: int):
        """获取许可证利用率统计 - 使用聚合查询"""
        from django.db.models import Count, F, Case, When
        
        return License.objects.filter(
            tenant_id=tenant_id,
            is_deleted=False
        ).annotate(
            active_assignments=Count('assignments', filter=Q(
                assignments__status='active',
                assignments__is_deleted=False
            )),
            utilization_rate=Case(
                When(max_activations=0, then=0),
                default=F('active_assignments') * 100 / F('max_activations'),
                output_field=IntegerField()
            )
        ).values(
            'id', 'license_key', 'product__name',
            'max_activations', 'active_assignments', 'utilization_rate'
        )
```

#### 缓存使用策略
```python
from django.core.cache import cache
from functools import wraps
import hashlib
import json

def cache_result(timeout=300, vary_on=None):
    """结果缓存装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 生成缓存键
            cache_key_data = {
                'func': f"{func.__module__}.{func.__name__}",
                'args': args,
                'kwargs': kwargs
            }
            
            if vary_on:
                for key in vary_on:
                    if key in kwargs:
                        cache_key_data[f'vary_{key}'] = kwargs[key]
            
            cache_key = hashlib.md5(
                json.dumps(cache_key_data, sort_keys=True).encode()
            ).hexdigest()
            
            # 尝试从缓存获取
            result = cache.get(cache_key)
            if result is not None:
                return result
            
            # 执行函数并缓存结果
            result = func(*args, **kwargs)
            cache.set(cache_key, result, timeout)
            
            return result
        return wrapper
    return decorator

class CachedAssignmentService:
    """带缓存的分配服务"""
    
    @cache_result(timeout=600, vary_on=['member_id'])
    def get_member_assignments(self, member_id: int):
        """获取成员分配 - 10分钟缓存"""
        return self.repository.find_by_member(member_id)
    
    @cache_result(timeout=300)
    def get_assignment_statistics(self, tenant_id: int):
        """获取分配统计 - 5分钟缓存"""
        return self.repository.get_statistics(tenant_id)
    
    def invalidate_member_cache(self, member_id: int):
        """失效成员相关缓存"""
        # 这里需要实现具体的缓存失效逻辑
        # 可以使用缓存标签或者模式匹配
        pass
```

## 🔒 安全最佳实践

### 数据验证和清理
```python
from django.core.exceptions import ValidationError
from typing import Any, Dict

class DataValidator:
    """数据验证器"""
    
    @staticmethod
    def validate_assignment_data(data: Dict[str, Any]) -> Dict[str, Any]:
        """验证分配数据"""
        cleaned_data = {}
        
        # 成员ID验证
        member_id = data.get('member_id')
        if not isinstance(member_id, int) or member_id <= 0:
            raise ValidationError("无效的成员ID")
        cleaned_data['member_id'] = member_id
        
        # 许可证ID验证
        license_id = data.get('license_id')
        if not isinstance(license_id, int) or license_id <= 0:
            raise ValidationError("无效的许可证ID")
        cleaned_data['license_id'] = license_id
        
        # 分配类型验证
        assignment_type = data.get('assignment_type', 'direct')
        valid_types = ['direct', 'group', 'auto', 'temporary']
        if assignment_type not in valid_types:
            raise ValidationError(f"无效的分配类型，必须是: {valid_types}")
        cleaned_data['assignment_type'] = assignment_type
        
        # 设备数量验证
        max_devices = data.get('max_concurrent_devices', 1)
        if not isinstance(max_devices, int) or max_devices < 1 or max_devices > 100:
            raise ValidationError("设备数量必须在1-100之间")
        cleaned_data['max_concurrent_devices'] = max_devices
        
        # 备注清理 (防止XSS)
        notes = data.get('assignment_notes', '')
        if notes:
            from html import escape
            cleaned_data['assignment_notes'] = escape(notes[:1000])  # 限制长度
        
        return cleaned_data
```

### 权限控制模式
```python
class PermissionChecker:
    """权限检查器"""
    
    def check_assignment_permission(
        self,
        user: Any,
        operation: str,
        resource: Dict[str, Any]
    ) -> bool:
        """检查分配权限"""
        
        # 租户管理员权限检查
        if user.is_admin:
            return self._check_tenant_admin_permission(user, operation, resource)
        
        # 普通用户权限检查
        return self._check_member_permission(user, operation, resource)
    
    def _check_tenant_admin_permission(self, user, operation, resource):
        """检查租户管理员权限"""
        tenant_id = resource.get('tenant_id')
        
        # 只能操作自己租户的资源
        if user.tenant_id != tenant_id:
            return False
        
        # 租户管理员可以进行大部分操作
        allowed_operations = ['create', 'read', 'update', 'assign', 'revoke']
        return operation in allowed_operations
    
    def _check_member_permission(self, user, operation, resource):
        """检查普通成员权限"""
        member_id = resource.get('member_id')
        
        # 只能操作自己的资源
        if user.id != member_id:
            return False
        
        # 普通成员只能进行只读操作
        allowed_operations = ['read', 'activate']
        return operation in allowed_operations
```

### 审计日志记录
```python
class SecurityAuditService:
    """安全审计服务"""
    
    def log_security_event(
        self,
        event_type: str,
        user_id: int,
        resource_type: str,
        resource_id: int,
        operation: str,
        success: bool,
        ip_address: str = None,
        user_agent: str = None,
        additional_data: Dict = None
    ):
        """记录安全事件"""
        
        audit_data = {
            'event_type': event_type,
            'user_id': user_id,
            'resource_type': resource_type,
            'resource_id': resource_id,
            'operation': operation,
            'success': success,
            'ip_address': ip_address,
            'user_agent': user_agent,
            'timestamp': timezone.now(),
            'additional_data': additional_data or {}
        }
        
        # 记录到数据库
        SecurityAuditLog.objects.create(**audit_data)
        
        # 记录到日志文件
        security_logger.info(
            f"安全事件: {event_type} - {operation} - {'成功' if success else '失败'}",
            extra=audit_data
        )
        
        # 高风险事件实时告警
        if event_type in ['unauthorized_access', 'privilege_escalation']:
            self._send_security_alert(audit_data)
    
    def _send_security_alert(self, audit_data):
        """发送安全告警"""
        # 实现告警逻辑
        pass
```

## 📊 监控和运维最佳实践

### 业务指标监控
```python
from django.core.management.base import BaseCommand
from django.db.models import Count, Q
from datetime import datetime, timedelta

class MonitoringService:
    """监控服务"""
    
    def collect_assignment_metrics(self):
        """收集分配指标"""
        now = timezone.now()
        today = now.date()
        yesterday = today - timedelta(days=1)
        
        metrics = {
            'timestamp': now.isoformat(),
            'assignment_stats': {
                'total_assignments': LicenseAssignment.objects.filter(
                    is_deleted=False
                ).count(),
                'active_assignments': LicenseAssignment.objects.filter(
                    status='active',
                    is_deleted=False
                ).count(),
                'daily_new_assignments': LicenseAssignment.objects.filter(
                    assigned_at__date=today
                ).count(),
                'daily_activations': LicenseAssignment.objects.filter(
                    activated_at__date=today
                ).count()
            },
            'license_utilization': self._calculate_license_utilization(),
            'performance_metrics': self._collect_performance_metrics()
        }
        
        return metrics
    
    def _calculate_license_utilization(self):
        """计算许可证利用率"""
        from django.db.models import F, Avg
        
        utilization = License.objects.filter(
            is_deleted=False
        ).annotate(
            active_count=Count('assignments', filter=Q(
                assignments__status='active',
                assignments__is_deleted=False
            )),
            utilization_rate=F('active_count') * 100.0 / F('max_activations')
        ).aggregate(
            avg_utilization=Avg('utilization_rate'),
            total_licenses=Count('id'),
            fully_utilized=Count('id', filter=Q(utilization_rate=100))
        )
        
        return utilization
    
    def _collect_performance_metrics(self):
        """收集性能指标"""
        # 这里可以集成APM工具的数据
        return {
            'avg_assignment_time': 0.8,  # 秒
            'avg_query_time': 0.05,      # 秒
            'cache_hit_rate': 85.3       # 百分比
        }
```

### 健康检查
```python
class HealthCheckService:
    """健康检查服务"""
    
    def check_system_health(self):
        """检查系统健康状态"""
        checks = {
            'database': self._check_database(),
            'cache': self._check_cache(),
            'external_services': self._check_external_services(),
            'business_logic': self._check_business_logic()
        }
        
        overall_status = all(check['status'] == 'healthy' for check in checks.values())
        
        return {
            'status': 'healthy' if overall_status else 'unhealthy',
            'timestamp': timezone.now().isoformat(),
            'checks': checks
        }
    
    def _check_database(self):
        """检查数据库连接"""
        try:
            LicenseAssignment.objects.count()
            return {'status': 'healthy', 'message': '数据库连接正常'}
        except Exception as e:
            return {'status': 'unhealthy', 'message': f'数据库连接失败: {str(e)}'}
    
    def _check_cache(self):
        """检查缓存服务"""
        try:
            cache.set('health_check', 'ok', 10)
            result = cache.get('health_check')
            if result == 'ok':
                return {'status': 'healthy', 'message': '缓存服务正常'}
            else:
                return {'status': 'unhealthy', 'message': '缓存读写失败'}
        except Exception as e:
            return {'status': 'unhealthy', 'message': f'缓存服务异常: {str(e)}'}
    
    def _check_business_logic(self):
        """检查业务逻辑"""
        try:
            # 执行一个简单的业务操作测试
            service = LicenseAssignmentDomainService()
            # 这里可以执行一些不会产生副作用的测试操作
            return {'status': 'healthy', 'message': '业务逻辑正常'}
        except Exception as e:
            return {'status': 'unhealthy', 'message': f'业务逻辑异常: {str(e)}'}
```

---

**下一步**: 查看[测试策略](09_测试策略.md)了解完整的测试方案
